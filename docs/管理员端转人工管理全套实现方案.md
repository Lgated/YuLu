# 管理员端转人工管理 - 全套后端实现方案（对齐 Redis 实现版）

本方案专为**租户管理员（Tenant Admin）**设计，支持对本租户内的转人工记录进行查询、客服状态实时监控以及运营通知广播。

- **权限模型**：基于租户隔离，管理员仅能操作所属租户的数据。
- **状态存储**：深度对接 `AgentStatusServiceImpl` 中的 Redis 存储结构。
- **核心组件**：DTO、VO、Service、Controller。

---

## 一、 数据展示与交互对象 (DTO & VO)

### 1.1 查询与操作 DTO

```java
package com.ityfz.yulu.handoff.admin.dto;

import lombok.Data;
import org.springframework.format.annotation.DateTimeFormat;
import javax.validation.constraints.NotBlank;
import java.time.LocalDateTime;

@Data
public class HandoffRecordQueryDTO {
    private Long userId;
    private Long agentId;
    private String status;
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startTime;
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime endTime;
    private Integer pageNo = 1;
    private Integer pageSize = 20;
}

@Data
public class AdminNotifyDTO {
    @NotBlank(message = "标题不能为空")
    private String title;
    @NotBlank(message = "内容不能为空")
    private String content;
}

@Data
public class ForceAgentStatusDTO {
    @NotBlank(message = "状态不能为空")
    private String status; // ONLINE, AWAY, OFFLINE
}
```

### 1.2 展示用 VO

```java
package com.ityfz.yulu.handoff.admin.vo;

import lombok.Builder;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@Builder
public class HandoffRecordVO {
    private Long handoffRequestId;
    private Long sessionId;
    private Long userId;
    private String userName;
    private Long agentId;
    private String agentName;
    private String status;
    private LocalDateTime createdAt;
    private LocalDateTime acceptedAt;
    private LocalDateTime completedAt;
    private Long waitDurationSeconds; // 申请 -> 接入耗时
    private Long chatDurationSeconds; // 接入 -> 完成耗时
}

@Data
@Builder
public class AgentMonitorVO {
    private Long agentId;
    private String agentName;
    private String status;           // 对应 Redis 中的 status
    private Integer currentSessions; // 对应 Redis 中的 current_sessions
    private Integer maxSessions;     // 对应 Redis 中的 max_sessions
    private String lastActiveTime;   // 对应 Redis 中的 last_active_time
}
```

---

## 二、 业务逻辑层 (Service)

### 2.1 AdminHandoffService (历史记录)

```java
package com.ityfz.yulu.handoff.admin.service;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.ityfz.yulu.handoff.admin.dto.HandoffRecordQueryDTO;
import com.ityfz.yulu.handoff.admin.vo.HandoffRecordVO;
import com.ityfz.yulu.handoff.entity.HandoffRequest;
import com.ityfz.yulu.handoff.mapper.HandoffRequestMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import java.time.Duration;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class AdminHandoffService {
    private final HandoffRequestMapper handoffRequestMapper;

    public Page<HandoffRecordVO> queryRecords(Long tenantId, HandoffRecordQueryDTO query) {
        LambdaQueryWrapper<HandoffRequest> qw = new LambdaQueryWrapper<HandoffRequest>()
                .eq(HandoffRequest::getTenantId, tenantId)
                .eq(query.getUserId() != null, HandoffRequest::getUserId, query.getUserId())
                .eq(query.getAgentId() != null, HandoffRequest::getAgentId, query.getAgentId())
                .eq(query.getStatus() != null, HandoffRequest::getStatus, query.getStatus())
                .ge(query.getStartTime() != null, HandoffRequest::getCreateTime, query.getStartTime())
                .le(query.getEndTime() != null, HandoffRequest::getCreateTime, query.getEndTime())
                .orderByDesc(HandoffRequest::getCreateTime);

        Page<HandoffRequest> page = handoffRequestMapper.selectPage(new Page<>(query.getPageNo(), query.getPageSize()), qw);
        
        List<HandoffRecordVO> vos = page.getRecords().stream().map(this::convertToVO).collect(Collectors.toList());
        Page<HandoffRecordVO> voPage = new Page<>(page.getCurrent(), page.getSize(), page.getTotal());
        voPage.setRecords(vos);
        return voPage;
    }

    private HandoffRecordVO convertToVO(HandoffRequest req) {
        Long wait = (req.getAcceptedAt() != null) ? Duration.between(req.getCreateTime(), req.getAcceptedAt()).getSeconds() : null;
        Long chat = (req.getCompletedAt() != null && req.getAcceptedAt() != null) ? Duration.between(req.getAcceptedAt(), req.getCompletedAt()).getSeconds() : null;
        
        return HandoffRecordVO.builder()
                .handoffRequestId(req.getId())
                .sessionId(req.getSessionId())
                .userId(req.getUserId())
                .userName("客户#" + req.getUserId())
                .agentId(req.getAgentId())
                .agentName(req.getAgentId() != null ? "客服#" + req.getAgentId() : "排队中")
                .status(req.getStatus())
                .createdAt(req.getCreateTime())
                .acceptedAt(req.getAcceptedAt())
                .completedAt(req.getCompletedAt())
                .waitDurationSeconds(wait)
                .chatDurationSeconds(chat)
                .build();
    }
}
```

### 2.2 AdminAgentManagementService (实时看板 - 对接 Redis)

```java
package com.ityfz.yulu.handoff.admin.service;

import com.ityfz.yulu.handoff.admin.vo.AgentMonitorVO;
import com.ityfz.yulu.handoff.dto.WebSocketMessage;
import com.ityfz.yulu.handoff.websocket.AgentWebSocketHandler;
import com.ityfz.yulu.user.service.AgentStatusService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.*;

@Service
@RequiredArgsConstructor
public class AdminAgentManagementService {
    private final AgentStatusService agentStatusService;
    private final AgentWebSocketHandler agentHandler;

    /**
     * 获取租户内客服的实时状态列表
     */
    public List<AgentMonitorVO> getAgentMonitorList(Long tenantId) {
        // 1. 获取当前租户在线客服 ID 列表（利用你现有的 getOnlineAgents 接口）
        List<Long> onlineAgentIds = agentStatusService.getOnlineAgents(tenantId);
        
        List<AgentMonitorVO> monitors = new ArrayList<>();
        for (Long agentId : onlineAgentIds) {
            // 2. 获取 Redis Hash 详细数据（对应你 getAgentStatus 接口）
            Map<String, Object> statusMap = agentStatusService.getAgentStatus(tenantId, agentId);
            
            monitors.add(AgentMonitorVO.builder()
                    .agentId(agentId)
                    .agentName("客服#" + agentId)
                    .status((String) statusMap.getOrDefault("status", "OFFLINE"))
                    .currentSessions(statusMap.get("current_sessions") != null ? (Integer) statusMap.get("current_sessions") : 0)
                    .maxSessions(statusMap.get("max_sessions") != null ? (Integer) statusMap.get("max_sessions") : 5)
                    .lastActiveTime((String) statusMap.get("last_active_time"))
                    .build());
        }
        return monitors;
    }

    /**
     * 管理员强制修改客服状态（如设为 AWAY 或离线）
     */
    public void forceUpdateAgentStatus(Long tenantId, Long agentId, String newStatus) {
        // 1. 调用现有的状态变更接口
        if ("ONLINE".equals(newStatus)) {
            agentStatusService.setOnline(tenantId, agentId);
        } else if ("AWAY".equals(newStatus)) {
            agentStatusService.setAway(tenantId, agentId);
        } else {
            agentStatusService.setOffline(tenantId, agentId);
        }
        
        // 2. 通过 WebSocket 发送通知给客服前端同步状态
        Map<String, Object> payload = new HashMap<>();
        payload.put("status", newStatus);
        
        WebSocketMessage msg = WebSocketMessage.builder()
                .type("ADMIN_FORCE_STATUS")
                .payload(payload)
                .timestamp(LocalDateTime.now().toString())
                .build();
        
        agentHandler.sendToAgent(tenantId, agentId, msg);
    }

    /**
     * 广播通知本租户所有客服
     */
    public void broadcastToTenant(Long tenantId, String title, String content) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("title", title);
        payload.put("content", content);
        
        WebSocketMessage msg = WebSocketMessage.builder()
                .type("ADMIN_NOTIFICATION")
                .payload(payload)
                .timestamp(LocalDateTime.now().toString())
                .build();
        
        // 此方法需要在 AgentWebSocketHandler 中实现（详见下方第四节）
        agentHandler.broadcastToTenant(tenantId, msg);
    }
}
```

---

## 三、 控制层 (Controller)

```java
package com.ityfz.yulu.handoff.admin.controller;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.ityfz.yulu.common.annotation.RequireRole;
import com.ityfz.yulu.common.model.ApiResponse;
import com.ityfz.yulu.common.security.SecurityUtil;
import com.ityfz.yulu.handoff.admin.dto.*;
import com.ityfz.yulu.handoff.admin.service.*;
import com.ityfz.yulu.handoff.admin.vo.*;
import lombok.RequiredArgsConstructor;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/admin/handoff")
@RequiredArgsConstructor
@Validated
@RequireRole("ADMIN")
public class AdminHandoffController {
    
    private final AdminHandoffService adminHandoffService;
    private final AdminAgentManagementService adminAgentService;

    @GetMapping("/records")
    public ApiResponse<Page<HandoffRecordVO>> getRecords(HandoffRecordQueryDTO query) {
        Long tenantId = SecurityUtil.currentTenantId();
        return ApiResponse.success(adminHandoffService.queryRecords(tenantId, query));
    }

    @GetMapping("/agent/status")
    public ApiResponse<List<AgentMonitorVO>> getAgentStatus() {
        Long tenantId = SecurityUtil.currentTenantId();
        return ApiResponse.success(adminAgentService.getAgentMonitorList(tenantId));
    }

    @PostMapping("/agent/{agentId}/status")
    public ApiResponse<Void> forceStatus(@PathVariable Long agentId, @RequestBody ForceAgentStatusDTO dto) {
        Long tenantId = SecurityUtil.currentTenantId();
        adminAgentService.forceUpdateAgentStatus(tenantId, agentId, dto.getStatus());
        return ApiResponse.success("客服状态已强制更新");
    }

    @PostMapping("/notify")
    public ApiResponse<Void> sendNotify(@RequestBody AdminNotifyDTO dto) {
        Long tenantId = SecurityUtil.currentTenantId();
        adminAgentService.broadcastToTenant(tenantId, dto.getTitle(), dto.getContent());
        return ApiResponse.success("通知已下发给该租户所有客服");
    }
}
```

---

## 四、 基础设施扩展建议

### 4.1 WebSocket 广播能力

在 `AgentWebSocketHandler` 中增加针对租户的广播方法：

```java
public void broadcastToTenant(Long tenantId, WebSocketMessage message) {
    // 假设你有维护 sessionId/agentId 到 WebSocketSession 的映射
    // 遍历在线的客服连接，匹配 tenantId 相同的进行下发
    log.info("[AgentWebSocket] 广播通知 - 租户: {}, 内容: {}", tenantId, message);
    // ... 发送逻辑
}
```

---

## 五、 实现要点总结

1. **Redis 交互**：`getAgentMonitorList` 循环调用 `getOnlineAgents` 和 `getAgentStatus`，从 Redis Hash 中提取 `status`, `current_sessions` 等实时数据。
2. **状态同步**：`forceUpdateAgentStatus` 在修改 Redis 后，通过 WS 类型 `ADMIN_FORCE_STATUS` 告知前端，确保客服界面状态同步变化。
3. **权限安全**：所有接口均从 `SecurityUtil` 获取 `tenantId`，天然支持租户管理员的隔离需求。
4. **统计细节**：在 VO 转换中计算了等待时长和通话时长，方便管理员分析客服效率。
