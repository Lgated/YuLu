第2部分：核心业务流程
一、转人工申请流程
1.1 完整时序图
用户端          后端API          HandoffService    AgentAssigner    Redis队列    WebSocket    客服端
  │               │                    │                │              │            │           │
  │─转人工请求────>│                    │                │              │            │           │
  │               │─transferToAgent──>│                │              │            │           │
  │               │                    │─验证会话────────>│              │            │           │
  │               │                    │─检查重复请求────>│              │            │           │
  │               │                    │─检查在线客服────>│              │            │           │
  │               │                    │─创建工单────────>│              │            │           │
  │               │                    │─创建请求记录────>│              │            │           │
  │               │                    │─加入队列────────────────────────>│            │           │
  │               │                    │─异步分配客服────>│              │            │           │
  │<─返回排队信息──│<───────────────────│                │              │            │           │
  │               │                    │                │              │            │           │
  │               │                    │  (1秒后)       │              │            │           │
  │               │                    │                │─查询在线客服─>│            │           │
  │               │                    │                │─多维度评分───>│            │           │
  │               │                    │                │─选择最优客服─>│            │           │
  │               │                    │<─返回agentId───│              │            │           │
  │               │                    │─更新请求状态────>│              │            │           │
  │               │                    │─更新会话agentId─>│              │            │           │
  │               │                    │─发送WebSocket通知──────────────────────────>│           │
  │               │                    │                │              │            │─通知客服──>│
1.2 代码实现（HandoffService.transferToAgent）
@Transactional
public HandoffTransferResponse transferToAgent(Long tenantId, Long userId, Long sessionId, String reason) {
    // 1. 验证会话
    ChatSession chatSession = chatSessionMapper.selectById(sessionId);
    if (chatSession == null || !chatSession.getTenantId().equals(tenantId)) {
        throw new BizException(ErrorCodes.UNAUTHORIZED, "会话不存在或无权限");
    }

    // 2. 检查是否已有未完成的转人工请求
    HandoffRequest existing = handoffRequestMapper.selectUncompletedBySessionId(sessionId);
    if (existing != null && !HandoffStatus.isCompleted(existing.getStatus())) {
        throw new BizException(ErrorCodes.VALIDATION_ERROR, "已有转人工请求，请勿重复申请");
    }

    // 3. 检查是否有客服在线（兜底策略）
    List<Long> onlineAgents = agentStatusService.getOnlineAgents(tenantId);
    if (onlineAgents.isEmpty()) {
        return handleFallbackToTicket(tenantId, userId, chatSession, reason);
    }

    // 4. 创建/关联工单
    Ticket ticket = findOrCreateTicket(tenantId, userId, sessionId, reason);

    // 5. 创建转人工请求
    HandoffRequest request = new HandoffRequest();
    request.setTenantId(tenantId);
    request.setSessionId(sessionId);
    request.setUserId(userId);
    request.setTicketId(ticket.getId());
    request.setStatus(HandoffStatus.PENDING.getCode());
    request.setReason(reason);
    request.setPriority(calculatePriority(chatSession));
    handoffRequestMapper.insert(request);

    // 6. 更新会话状态
    chatSession.setChatMode("AGENT");
    chatSession.setHandoffRequestId(request.getId());
    chatSessionMapper.updateById(chatSession);

    // 7. 加入排队队列
    int queuePosition = handoffQueueService.addToQueue(tenantId, request.getId());

    // 8. 记录事件
    recordEvent(request.getId(), HandoffEventType.CREATED, userId, OperatorType.USER, null);

    // 9. 异步触发智能分配
    asyncAssignAgent(tenantId, request.getId());

    // 10. 返回结果
    return HandoffTransferResponse.builder()
            .handoffRequestId(request.getId())
            .ticketId(ticket.getId())
            .queuePosition(queuePosition)
            .estimatedWaitTime(calculateEstimatedWaitTime(tenantId, queuePosition))
            .build();
}
二、智能分配算法
2.1 多维度评分算法
private double calculateScore(AgentCandidate candidate, HandoffRequest request) {
    double score = 0.0;
    
    // 1. 在线状态权重：40%
    if ("ONLINE".equals(candidate.getStatus())) {
        score += 40;
    } else if ("AWAY".equals(candidate.getStatus())) {
        score += 20;
    }
    
    // 2. 负载权重：30%
    if (candidate.getMaxSessions() > 0) {
        double loadRatio = candidate.getCurrentSessions() / (double) candidate.getMaxSessions();
        score += 30 * (1 - loadRatio);  // 负载越低，分数越高
    }
    
    // 3. 技能匹配权重：20%
    if (candidate.getSkillTags() != null && !candidate.getSkillTags().isEmpty()) {
        score += 20;
    }
    
    // 4. 历史服务质量权重：10%
    score += 10;  // 默认给10分
    
    // 5. 优先级加成
    if ("URGENT".equals(request.getPriority()) && candidate.isSeniorAgent()) {
        score += 10;
    }
    
    // 6. 自动接入加成
    if (candidate.isAutoAccept()) {
        score += 5;
    }
    
    return score;
}
2.2 分配流程
1. 获取所有在线客服列表
   ↓
2. 构建候选客服列表（包含状态、负载、技能等信息）
   ↓
3. 对每个候选客服进行多维度评分
   ↓
4. 按分数降序排序
   ↓
5. 选择第一个可接入的客服（负载未满）
   ↓
6. 返回客服ID
三、WebSocket 实时通信
3.1 连接管理
客服端连接：

ws://localhost:8080/ws/agent?token=xxx
  ↓
解析 JWT token
  ↓
提取 tenantId 和 agentId
  ↓
存储连接：agent:{tenantId}:{agentId}
用户端连接：

ws://localhost:8080/ws/customer?token=xxx&sessionId=xxx
  ↓
解析 JWT token
  ↓
提取 tenantId、userId 和 sessionId
  ↓
存储连接：customer:{tenantId}:{userId}:{sessionId}
3.2 消息类型
类型	方向	说明
HANDOFF_REQUEST	后端→客服	新的转人工请求通知
HANDOFF_ACCEPTED	后端→用户	客服已接受通知
HANDOFF_CANCELLED	后端→客服	用户取消通知
HANDOFF_COMPLETED	后端→双方	会话结束通知
TEXT	双向	文本消息
TYPING	双向	正在输入提示
ERROR	后端→前端	错误消息
四、关键技术细节
4.1 为什么需要同步更新 chat_session.agent_id？
问题场景：

// 错误的实现（只更新 handoff_request）
request.setAgentId(agentId);
handoffRequestMapper.updateById(request);
// 缺少：session.setAgentId(agentId);
导致的问题：

用户发送消息时，WebSocketMessageService 检查 session.agent_id 为 NULL
抛出异常："当前会话未接入客服"
用户无法与客服正常对话
正确的实现：

// 同时更新 handoff_request 和 chat_session
request.setAgentId(agentId);
handoffRequestMapper.updateById(request);

ChatSession session = chatSessionMapper.selectById(request.getSessionId());
session.setAgentId(agentId);
chatSessionMapper.updateById(session);
4.2 为什么使用 @Lazy 注解？
循环依赖问题：

WebSocketMessageService 依赖 CustomerWebSocketHandler
CustomerWebSocketHandler 依赖 WebSocketMessageService
解决方案：

public WebSocketMessageService(
    ChatSessionMapper chatSessionMapper,
    ChatMessageMapper chatMessageMapper,
    @Lazy CustomerWebSocketHandler customerHandler,  // 延迟加载
    @Lazy AgentWebSocketHandler agentHandler) {
    // ...
}
原理：

@Lazy 告诉 Spring 先创建一个代理对象
等到第一次真正使用时，再完全创建 Bean
打破循环依赖
4.3 租户上下文管理
为什么需要手动设置租户上下文？

在 WebSocket 处理器中，MyBatis-Plus 的租户插件无法自动获取租户ID，需要手动设置：

@Override
protected void handleTextMessage(WebSocketSession session, TextMessage message) {
    Long tenantId = (Long) session.getAttributes().get("tenantId");
    
    // 设置租户上下文
    TenantContextHolder.setTenantId(tenantId);
    try {
        // 业务逻辑（MyBatis-Plus 会自动添加 tenant_id 条件）
        messageService.handleCustomerMessage(tenantId, userId, sessionId, wsMessage);
    } finally {
        // 清理租户上下文（避免内存泄漏）
        TenantContextHolder.clear();
    }
}
第3部分：面试问题解答
问题1：介绍一下你的转人工功能是怎么实现的？
回答思路：

"我实现的转人工功能是一个完整的智能客服系统核心模块，主要包括以下几个方面：

1. 整体架构：

采用前后端分离架构，后端使用 Spring Boot + MyBatis-Plus
使用 WebSocket 实现实时双向通信
使用 Redis 管理排队队列和客服状态
支持多租户隔离
2. 核心流程：

用户发起转人工请求 → 创建请求记录 → 加入排队队列
异步触发智能分配算法 → 多维度评分选择最优客服
WebSocket 实时通知客服 → 客服接受/拒绝
建立用户-客服对话通道 → 实时消息转发
会话结束 → 释放客服资源
3. 技术亮点：

智能分配算法：基于客服在线状态、当前负载、技能匹配等多维度评分
兜底策略：无客服在线时自动转工单，确保问题不遗漏
状态机管理：9种状态流转，覆盖所有业务场景
事件审计：完整记录所有操作，便于问题追溯
4. 解决的难点：

并发场景下的客服负载管理（Redis 原子操作）
WebSocket 连接管理和消息可靠性
多租户数据隔离
循环依赖问题（@Lazy 注解）"
问题2：你的智能分配算法是怎么设计的？
回答：

"我设计的智能分配算法采用多维度评分机制，主要考虑以下几个维度：

1. 在线状态（权重40%）：

ONLINE 状态：40分
AWAY 状态：20分
OFFLINE 状态：0分
2. 负载情况（权重30%）：

计算公式：30 * (1 - current_sessions / max_sessions)
负载越低，分数越高
例如：当前0个会话，最大5个 → 得分30分
3. 技能匹配（权重20%）：

根据客服的技能标签与转人工原因匹配
匹配度越高，分数越高
4. 服务质量（权重10%）：

基于历史服务评价、响应速度等
目前简化为固定10分，后续可以从历史数据计算
5. 额外加成：

紧急请求优先分配给高级客服（+10分）
配置了自动接入的客服优先（+5分）
分配流程：

获取所有在线客服
对每个客服进行评分
按分数降序排序
选择第一个负载未满的客服
优势：

负载均衡：避免某个客服过载
灵活扩展：易于添加新的评分维度
公平合理：综合考虑多个因素"
问题3：如何保证高并发场景下的数据一致性？
回答：

"我从以下几个方面保证数据一致性：

1. 数据库层面：

使用 @Transactional 注解保证事务一致性
关键操作（创建请求、分配客服、更新状态）都在同一事务中
使用乐观锁或悲观锁防止并发更新冲突
2. Redis 层面：

使用 Redis 的原子操作（RPUSH、LPOP、HINCRBY）
客服负载计数使用 INCR/DECR 保证原子性
队列操作使用 LIST 数据结构，天然支持并发
3. 应用层面：

异步分配客服，避免阻塞主流程
使用 ConcurrentHashMap 管理 WebSocket 连接
关键代码段添加同步锁
4. 业务层面：

检查重复请求：防止用户重复提交
检查客服负载：分配前再次确认是否可接入
状态校验：每个操作都验证当前状态是否允许
5. 容错处理：

分配失败时请求保持在队列中，可重试
WebSocket 断线重连机制
定时任务清理异常状态的请求"
问题4：WebSocket 为什么不用 Redis 存储连接？
回答：

"这是一个很好的问题。我使用 ConcurrentHashMap 而不是 Redis 存储 WebSocket 连接，主要基于以下考虑：

使用内存 Map 的原因：

性能考虑：

WebSocket 连接对象（WebSocketSession）无法序列化到 Redis
每次发送消息都需要从 Redis 读取，增加网络开销
内存操作比 Redis 网络调用快10-100倍
连接特性：

WebSocket 连接是有状态的，必须在当前服务器实例上
即使存到 Redis，其他服务器也无法使用这个连接对象
简单高效：

不需要序列化/反序列化
代码简单，易于维护
分布式场景的解决方案：

如果需要支持分布式部署，可以采用以下方案：

Session Sticky（会话粘性）：

负载均衡器配置，同一用户的请求总是路由到同一台服务器
Nginx 的 ip_hash 或 cookie 粘性
Redis Pub/Sub：

连接仍然存在本地 Map
使用 Redis 发布/订阅机制跨服务器通信
服务器A收到消息 → 发布到 Redis → 服务器B订阅到 → 发送给客户端
消息队列：

使用 RabbitMQ 或 Kafka 实现跨服务器消息传递
当前实现的适用场景：

单机部署或小规模集群
使用 Session Sticky 的分布式部署
对实时性要求高的场景"
问题5：如果客服突然断线怎么办？
回答：

"我设计了完善的客服断线处理机制：

1. 心跳机制：

客服端每30秒发送一次心跳
后端更新 Redis 中的 heartbeat_time 和 TTL
如果30分钟无心跳，Redis key 自动过期，客服自动下线
2. 断线检测：

@Override
public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
    // 清理连接
    String connectionKey = buildConnectionKey(tenantId, agentId);
    agentSessions.remove(connectionKey);
    
    // 可以在这里触发会话转移逻辑
    handleAgentDisconnection(tenantId, agentId);
}
3. 会话转移策略：

方案A：自动转移给其他客服

private void handleAgentDisconnection(Long tenantId, Long agentId) {
    // 1. 查询该客服的所有进行中会话
    List<HandoffRequest> requests = handoffRequestMapper.selectInProgressByAgent(tenantId, agentId);
    
    // 2. 将会话重新加入队列
    for (HandoffRequest request : requests) {
        request.setStatus(HandoffStatus.PENDING.getCode());
        request.setAgentId(null);
        handoffRequestMapper.updateById(request);
        
        // 重新加入队列
        queueService.addToQueue(tenantId, request.getId());
        
        // 触发重新分配
        asyncAssignAgent(tenantId, request.getId());
    }
    
    // 3. 通知用户
    sendAgentDisconnectedNotification(requests);
}
方案B：暂停会话，等待客服重连

设置会话状态为 PAUSED
给用户发送提示："客服暂时离线，请稍候"
客服重连后自动恢复会话
方案C：转为工单

如果客服长时间未重连（如5分钟）
自动将会话转为工单
通知用户："已为您创建工单，稍后会有客服处理"
当前实现：

采用方案B（暂停等待）+ 方案C（超时转工单）
平衡了用户体验和系统稳定性"
问题6：如何防止恶意用户频繁发起转人工请求？
回答：

"我设计了多层防护机制：

1. 业务层面：

// 检查是否已有未完成的转人工请求
HandoffRequest existing = handoffRequestMapper.selectUncompletedBySessionId(sessionId);
if (existing != null && !HandoffStatus.isCompleted(existing.getStatus())) {
    throw new BizException(ErrorCodes.VALIDATION_ERROR, "已有转人工请求，请勿重复申请");
}
2. 频率限制：

// 使用 Redis 记录用户请求次数
String rateLimitKey = "handoff:rate:" + tenantId + ":" + userId;
Long count = redisTemplate.opsForValue().increment(rateLimitKey);
if (count == 1) {
    redisTemplate.expire(rateLimitKey, 1, TimeUnit.MINUTES);
}
if (count > 3) {  // 1分钟内最多3次
    throw new BizException(ErrorCodes.TOO_MANY_REQUESTS, "请求过于频繁，请稍后再试");
}
3. 前端防抖：

const [isSubmitting, setIsSubmitting] = useState(false);

const handleTransfer = async () => {
  if (isSubmitting) return;
  
  setIsSubmitting(true);
  try {
    await handoffApi.transfer(sessionId, reason);
  } finally {
    setTimeout(() => setIsSubmitting(false), 2000);
  }
};
4. 监控告警：

记录每个用户的转人工次数
超过阈值时触发告警
人工审核是否为恶意行为
5. 黑名单机制：

对确认的恶意用户加入黑名单
限制其转人工功能"
总结
这个转人工功能的实现涵盖了：

✅ 完整的业务流程设计
✅ 智能的客服分配算法
✅ 实时的 WebSocket 通信
✅ 可靠的数据一致性保证
✅ 完善的异常处理机制
✅ 良好的扩展性和可维护性
通过这个项目，我深入理解了分布式系统设计、实时通信、状态机管理等核心技术，也积累了处理高并发、保证数据一致性的实战经验。