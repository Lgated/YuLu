# 转人工功能 - 完整技术文档（第1部分：架构设计）

> 本文档详细讲解智能客服系统中转人工功能的完整实现，包括架构设计、核心逻辑、技术细节和面试要点。

---

## 📚 目录

- 第1部分：架构设计（本文档）
- 第2部分：核心业务流程
- 第3部分：技术实现细节
- 第4部分：面试问题解答

---

## 一、功能概述

### 1.1 业务场景

**转人工（Handoff）** 是智能客服系统的核心功能之一，当AI无法解决用户问题时，用户可以申请转接到人工客服，实现AI到人工的无缝切换。

### 1.2 核心价值

1. **提升用户体验**：复杂问题由人工处理，提高问题解决率
2. **优化资源分配**：简单问题AI处理，人工专注复杂问题
3. **数据闭环**：记录转人工原因，优化AI能力
4. **服务保障**：无客服在线时自动转工单，确保问题不遗漏

### 1.3 功能特点

- ✅ 智能客服分配算法（多维度评分）
- ✅ 排队队列管理（Redis实现）
- ✅ 实时通信（WebSocket双向通信）
- ✅ 多租户隔离（租户级别数据隔离）
- ✅ 状态机管理（9种状态流转）
- ✅ 兜底策略（无客服在线自动转工单）
- ✅ 事件审计（完整的操作记录）

---

## 二、系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        前端层（Frontend）                      │
├─────────────────────────────────────────────────────────────┤
│  用户端（Customer）          │         客服端（Agent）         │
│  - 转人工申请                │         - 接受/拒绝请求         │
│  - 排队状态查询              │         - 实时对话             │
│  - 取消排队                  │         - 完成会话             │
│  - 实时对话                  │         - 工作台管理           │
└─────────────────────────────────────────────────────────────┘
                              ↓ HTTP/WebSocket
┌─────────────────────────────────────────────────────────────┐
│                        控制器层（Controller）                  │
├─────────────────────────────────────────────────────────────┤
│  CustomerHandoffController   │   AgentHandoffController      │
│  - POST /transfer            │   - GET /pending              │
│  - GET /status/{id}          │   - POST /accept              │
│  - POST /cancel/{id}         │   - POST /reject              │
│  - POST /end-by-user         │   - POST /complete/{id}       │
│                              │   - GET /by-session/{id}      │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                        服务层（Service）                       │
├─────────────────────────────────────────────────────────────┤
│  HandoffService              │   AgentAssigner               │
│  - 转人工申请                │   - 智能分配算法               │
│  - 客服接受/拒绝             │   - 多维度评分                │
│  - 完成/取消                 │   - 负载均衡                  │
│  - 状态查询                  │                               │
├─────────────────────────────────────────────────────────────┤
│  HandoffQueueService         │   WebSocketMessageService     │
│  - 队列管理（Redis）         │   - 消息转发                  │
│  - 排队位置计算              │   - 消息持久化                │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      WebSocket 层                             │
├─────────────────────────────────────────────────────────────┤
│  CustomerWebSocketHandler    │   AgentWebSocketHandler       │
│  - 用户连接管理              │   - 客服连接管理               │
│  - 消息接收/发送             │   - 消息接收/发送             │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                        数据层（Data）                          │
├─────────────────────────────────────────────────────────────┤
│  MySQL                       │   Redis                       │
│  - handoff_request           │   - handoff:queue:{tenantId}  │
│  - handoff_event             │   - agent:status:{t}:{a}      │
│  - chat_session              │   - agent:sessions:{t}:{a}    │
│  - chat_message              │   - agent:online:{tenantId}   │
│  - ticket                    │                               │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 技术栈

| 层次 | 技术选型 | 说明 |
|------|---------|------|
| **后端框架** | Spring Boot 2.x | 主框架 |
| **持久层** | MyBatis-Plus | ORM框架，支持多租户插件 |
| **数据库** | MySQL 8.0 | 关系型数据库 |
| **缓存** | Redis | 队列、客服状态管理 |
| **实时通信** | Spring WebSocket | 双向实时通信 |
| **异步处理** | @Async | 异步客服分配 |
| **API文档** | Swagger 3.0 | 接口文档 |
| **前端框架** | React + TypeScript | 用户界面 |

---

## 三、模块划分

### 3.1 目录结构

```
src/main/java/com/ityfz/yulu/handoff/
├── controller/                    # 控制器层
│   ├── AgentHandoffController.java       # 客服端接口
│   └── CustomerHandoffController.java    # 用户端接口
├── dto/                          # 数据传输对象
│   ├── HandoffTransferRequest.java       # 转人工请求DTO
│   ├── HandoffTransferResponse.java      # 转人工响应DTO
│   ├── HandoffStatusResponse.java        # 状态查询响应DTO
│   ├── HandoffAcceptRequest.java         # 接受请求DTO
│   ├── HandoffRejectRequest.java         # 拒绝请求DTO
│   ├── EndHandoffByUserRequest.java      # 用户结束请求DTO
│   ├── HandoffRequestItemDTO.java        # 请求列表项DTO
│   └── WebSocketMessage.java             # WebSocket消息DTO
├── entity/                       # 实体类
│   ├── HandoffRequest.java               # 转人工请求实体
│   └── HandoffEvent.java                 # 转人工事件实体
├── enums/                        # 枚举类
│   ├── HandoffStatus.java                # 转人工状态枚举
│   ├── HandoffEventType.java             # 事件类型枚举
│   └── OperatorType.java                 # 操作人类型枚举
├── mapper/                       # 数据访问层
│   ├── HandoffRequestMapper.java         # 转人工请求Mapper
│   └── HandoffEventMapper.java           # 转人工事件Mapper
└── websocket/                    # WebSocket层
    ├── AgentWebSocketHandler.java        # 客服WebSocket处理器
    ├── CustomerWebSocketHandler.java     # 用户WebSocket处理器
    ├── WebSocketHandshakeInterceptor.java # WebSocket握手拦截器
    └── service/                          # WebSocket服务层
        ├── HandoffService.java           # 转人工核心服务
        ├── AgentAssigner.java            # 智能分配器
        ├── HandoffQueueService.java      # 队列服务
        └── WebSocketMessageService.java  # 消息服务
```

### 3.2 核心类职责

| 类名 | 职责 | 关键方法 |
|------|------|---------|
| **HandoffService** | 转人工核心业务逻辑 | transferToAgent, acceptHandoff, complete, cancel |
| **AgentAssigner** | 智能客服分配算法 | assignAgent, calculateScore |
| **HandoffQueueService** | 排队队列管理 | addToQueue, removeFromQueue, getQueuePosition |
| **WebSocketMessageService** | 消息转发与持久化 | handleCustomerMessage, handleAgentMessage |
| **AgentWebSocketHandler** | 客服WebSocket连接管理 | sendToAgent |
| **CustomerWebSocketHandler** | 用户WebSocket连接管理 | sendToCustomer |

---

## 四、数据模型设计

### 4.1 核心表结构

#### handoff_request（转人工请求表）

```sql
CREATE TABLE `handoff_request` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `tenant_id` BIGINT(20) NOT NULL COMMENT '租户ID',
  `session_id` BIGINT(20) NOT NULL COMMENT '会话ID',
  `user_id` BIGINT(20) NOT NULL COMMENT '客户ID',
  `ticket_id` BIGINT(20) DEFAULT NULL COMMENT '关联工单ID',
  `agent_id` BIGINT(20) DEFAULT NULL COMMENT '分配的客服ID',
  `status` VARCHAR(20) NOT NULL DEFAULT 'PENDING' COMMENT '状态',
  `priority` VARCHAR(20) NOT NULL DEFAULT 'MEDIUM' COMMENT '优先级',
  `reason` VARCHAR(500) DEFAULT NULL COMMENT '转人工原因',
  `queue_position` INT(11) DEFAULT NULL COMMENT '排队位置',
  `assigned_at` DATETIME DEFAULT NULL COMMENT '分配时间',
  `accepted_at` DATETIME DEFAULT NULL COMMENT '接受时间',
  `started_at` DATETIME DEFAULT NULL COMMENT '开始时间',
  `completed_at` DATETIME DEFAULT NULL COMMENT '完成时间',
  `closed_at` DATETIME DEFAULT NULL COMMENT '关闭时间',
  `reject_reason` VARCHAR(500) DEFAULT NULL COMMENT '拒绝原因',
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_tenant_session` (`tenant_id`, `session_id`),
  KEY `idx_tenant_agent` (`tenant_id`, `agent_id`),
  KEY `idx_tenant_status` (`tenant_id`, `status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='转人工请求表';
```

#### handoff_event（转人工事件表）

```sql
CREATE TABLE `handoff_event` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `tenant_id` BIGINT(20) NOT NULL COMMENT '租户ID',
  `handoff_request_id` BIGINT(20) NOT NULL COMMENT '转人工请求ID',
  `event_type` VARCHAR(50) NOT NULL COMMENT '事件类型',
  `event_data` TEXT COMMENT '事件数据（JSON）',
  `operator_id` BIGINT(20) DEFAULT NULL COMMENT '操作人ID',
  `operator_type` VARCHAR(20) DEFAULT NULL COMMENT '操作人类型',
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_handoff_request_id` (`handoff_request_id`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='转人工事件记录表';
```

#### chat_session（会话表扩展）

```sql
ALTER TABLE `chat_session` 
ADD COLUMN `handoff_request_id` BIGINT(20) DEFAULT NULL COMMENT '转人工请求ID',
ADD COLUMN `agent_id` BIGINT(20) DEFAULT NULL COMMENT '当前接入的客服ID',
ADD COLUMN `chat_mode` VARCHAR(20) NOT NULL DEFAULT 'AI' COMMENT '对话模式：AI/AGENT',
ADD KEY `idx_handoff_request_id` (`handoff_request_id`),
ADD KEY `idx_agent_id` (`agent_id`);
```

### 4.2 状态机设计

#### 状态枚举（HandoffStatus）

```java
public enum HandoffStatus {
    PENDING("PENDING", "排队中"),           // 初始状态
    ASSIGNED("ASSIGNED", "已分配"),         // 已分配客服
    ACCEPTED("ACCEPTED", "已接受"),         // 客服已接受
    IN_PROGRESS("IN_PROGRESS", "进行中"),   // 对话进行中
    COMPLETED("COMPLETED", "已完成"),       // 正常完成
    CLOSED("CLOSED", "已关闭"),             // 正常关闭
    REJECTED("REJECTED", "已拒绝"),         // 客服拒绝
    CANCELLED("CANCELLED", "已取消"),       // 用户取消
    FALLBACK_TICKET("FALLBACK_TICKET", "已转为工单"); // 兜底策略
}
```

#### 状态流转图

```
                    ┌─────────────┐
                    │   PENDING   │ ← 用户发起转人工
                    │   (排队中)   │
                    └──────┬──────┘
                           │
                ┌──────────┼──────────┐
                │          │          │
                ↓          ↓          ↓
         ┌──────────┐  ┌──────────┐  ┌──────────────┐
         │CANCELLED │  │ ASSIGNED │  │FALLBACK_TICKET│
         │ (已取消)  │  │ (已分配)  │  │ (转为工单)    │
         └──────────┘  └────┬─────┘  └──────────────┘
                            │
                    ┌───────┼───────┐
                    │       │       │
                    ↓       ↓       ↓
            ┌──────────┐ ┌──────────┐
            │ REJECTED │ │ ACCEPTED │
            │ (已拒绝)  │ │ (已接受)  │
            └──────────┘ └────┬─────┘
                              │
                              ↓
                       ┌──────────────┐
                       │ IN_PROGRESS  │
                       │  (进行中)     │
                       └──────┬───────┘
                              │
                    ┌─────────┼─────────┐
                    │         │         │
                    ↓         ↓         ↓
            ┌──────────┐ ┌──────────┐ ┌──────────┐
            │COMPLETED │ │  CLOSED  │ │CANCELLED │
            │ (已完成)  │ │ (已关闭)  │ │ (已取消)  │
            └──────────┘ └──────────┘ └──────────┘
```

### 4.3 Redis 数据结构

#### 客服状态（HASH）
```
Key: agent:status:{tenantId}:{agentId}
Type: HASH
Fields:
  status: "ONLINE" / "OFFLINE" / "AWAY"
  current_sessions: 当前会话数（整数）
  max_sessions: 最大并发数（整数）
  heartbeat_time: 心跳时间戳
  last_active_time: 最后活跃时间
```

#### 排队队列（LIST）
```
Key: handoff:queue:{tenantId}
Type: LIST
Values: [handoffRequestId1, handoffRequestId2, ...]
Operations:
  - RPUSH: 加入队尾
  - LPOP: 从队首取出
  - LREM: 移除指定元素
  - LRANGE: 查看队列
```

#### 在线客服集合（ZSET）
```
Key: agent:online:{tenantId}
Type: ZSET
Members: agentId
Score: 上线时间戳
```

---

## 五、设计模式与原则

### 5.1 使用的设计模式

1. **策略模式**：智能分配算法（AgentAssigner）
2. **状态模式**：转人工状态流转（HandoffStatus）
3. **观察者模式**：WebSocket消息推送
4. **工厂模式**：WebSocket连接管理
5. **单例模式**：Service层Bean管理

### 5.2 设计原则

1. **单一职责原则**：每个类只负责一个功能模块
2. **开闭原则**：易于扩展新的分配策略
3. **依赖倒置原则**：面向接口编程
4. **接口隔离原则**：用户端和客服端接口分离

---

## 六、关键技术决策

### 6.1 为什么使用 Redis 而不是数据库队列？

**优势**：
- 高性能：内存操作，毫秒级响应
- 原子操作：LPUSH/RPUSH 保证并发安全
- 过期机制：自动清理过期队列
- 简单高效：LIST 数据结构天然适合队列

**劣势**：
- 数据持久化：需要配置 RDB/AOF
- 内存限制：大量请求时需要考虑内存

### 6.2 为什么使用 WebSocket 而不是轮询？

**优势**：
- 实时性：毫秒级消息推送
- 低延迟：无需等待轮询间隔
- 节省资源：减少HTTP请求
- 双向通信：服务端可主动推送

**劣势**：
- 连接管理：需要维护连接状态
- 负载均衡：需要支持WebSocket的负载均衡器

### 6.3 为什么使用异步分配客服？

**原因**：
- 避免阻塞：转人工请求立即返回
- 提升体验：用户无需等待分配完成
- 解耦逻辑：分配失败不影响请求创建
- 重试机制：分配失败可以重试

---

## 七、多租户设计

### 7.1 租户隔离策略

1. **数据库层面**：所有表都有 `tenant_id` 字段
2. **MyBatis-Plus 插件**：自动添加租户条件
3. **Redis 层面**：Key 包含 `tenantId`
4. **WebSocket 层面**：连接Key包含 `tenantId`

### 7.2 租户上下文管理

```java
// 设置租户上下文
TenantContextHolder.setTenantId(tenantId);
try {
    // 业务逻辑
} finally {
    // 清理租户上下文
    TenantContextHolder.clear();
}
```

---

**下一部分**：核心业务流程详解
