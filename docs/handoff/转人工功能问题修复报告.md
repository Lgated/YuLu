# 转人工功能问题修复报告

## 问题现象

1. **用户端**：发送转人工请求后，一直显示"排队中"，无法与客服建立连接
2. **客服端**：没有收到转人工请求通知，无法看到待处理的转人工请求
3. **后端报错**：
   - `BizException: 当前会话未接入客服`
   - `agent message missing sessionId`
   - WebSocket 状态异常：`TEXT_PARTIAL_WRITING`

## 根本原因分析

### 1. 核心问题：会话状态不一致

从数据库查询日志可以看到：
```sql
<==  Row: 26, 1, 2, 新会话 02-06 17:25, 1, 24, null, AGENT, 2026-02-06 17:25:32
```

关键字段：
- `handoff_request_id`: 24 ✅ (已设置)
- `agent_id`: **null** ❌ (未设置！)
- `chat_mode`: AGENT ✅ (已设置)

**问题**：`chat_session` 表的 `agent_id` 字段为 null，导致消息验证失败。

### 2. 转人工流程断裂

正常流程应该是：
```
1. 用户申请转人工
   ↓
2. 创建 HandoffRequest (status=PENDING)
   ↓
3. 更新 ChatSession (chat_mode=AGENT, handoff_request_id=xxx)
   ↓
4. 异步分配客服
   ↓
5. 更新 HandoffRequest (agent_id=xxx, status=ASSIGNED)
   ↓
6. 【缺失】更新 ChatSession (agent_id=xxx) ❌
   ↓
7. 发送 WebSocket 通知给客服
```

**断裂点**：在步骤6，`HandoffService.asyncAssignAgent()` 方法中，只更新了 `HandoffRequest` 的 `agent_id`，但**没有同步更新 `ChatSession` 的 `agent_id`**。

### 3. 消息验证失败

在 `WebSocketMessageService.handleCustomerMessage()` 中：
```java
// 验证是否已接入客服
if (session.getAgentId() == null || !"AGENT".equals(session.getChatMode())){
    throw new BizException(ErrorCodes.VALIDATION_ERROR,"当前会话未接入客服");
}
```

因为 `session.getAgentId()` 为 null，所以抛出异常，导致用户无法发送消息。

### 4. 客服端未收到通知

虽然 `sendHandoffRequestNotification()` 方法被调用了，但由于前面的流程问题，可能导致：
- 客服 WebSocket 连接未正确建立
- 消息发送时机不对
- 客服端没有正确监听 `HANDOFF_REQUEST` 消息类型

## 解决方案

### 修复1：同步更新会话的 agent_id

在 `HandoffService.asyncAssignAgent()` 方法中，分配客服成功后，同步更新 `ChatSession` 的 `agentId`：

```java
@Async
private void asyncAssignAgent(Long tenantId, Long handoffRequestId) {
    try {
        Thread.sleep(1000); // 延迟1秒，确保请求已保存

        Long agentId = agentAssigner.assignAgent(tenantId, handoffRequestId);
        if (agentId != null) {
            // 分配成功，更新请求状态
            HandoffRequest request = handoffRequestMapper.selectById(handoffRequestId);
            request.setAgentId(agentId);
            request.setStatus(HandoffStatus.ASSIGNED.getCode());
            request.setAssignedAt(LocalDateTime.now());
            handoffRequestMapper.updateById(request);

            // 【关键修复】同步更新会话的 agentId
            ChatSession session = chatSessionMapper.selectById(request.getSessionId());
            if (session != null) {
                session.setAgentId(agentId);
                chatSessionMapper.updateById(session);
                log.info("[HandoffService] 已更新会话的客服ID：sessionId={}, agentId={}", 
                    session.getId(), agentId);
            }

            // 记录事件
            recordEvent(handoffRequestId, HandoffEventType.ASSIGNED, agentId, 
                OperatorType.SYSTEM, null);

            // WebSocket推送通知给客服
            sendHandoffRequestNotification(tenantId, agentId, request);
        } else {
            log.warn("[HandoffService] 未找到可分配的客服：handoffRequestId={}", 
                handoffRequestId);
        }
    } catch (Exception e) {
        log.error("[HandoffService] 异步分配客服失败：handoffRequestId={}", 
            handoffRequestId, e);
    }
}
```

### 修复2：前端确保发送消息时包含 sessionId

在 `AgentWorkbenchPage.tsx` 中，发送消息时必须包含 `sessionId`：

```typescript
const handleSendMessage = (sessionId: number, content: string) => {
  if (!wsClientRef.current) return;

  // 构造包含 sessionId 的 payload
  const payload = { sessionId, content };
  wsClientRef.current.send('TEXT', payload);

  // 乐观更新 UI
  const newMessage: ChatMessage = {
    id: Date.now(),
    senderType: 'AGENT',
    content,
    createTime: new Date().toISOString(),
  } as any;

  setActiveSessions(prev => {
    const newSessions = new Map(prev);
    const session = newSessions.get(sessionId);
    if (session) {
      session.messages.push(newMessage);
    }
    return newSessions;
  });
};
```

### 修复3：添加更详细的日志

在关键节点添加日志，便于排查问题：

1. **转人工申请时**：记录会话状态
2. **分配客服时**：记录分配结果和会话更新
3. **WebSocket 消息处理时**：记录消息类型和 payload
4. **客服接受请求时**：记录会话绑定情况

## 验证步骤

### 1. 后端验证

启动后端服务，观察日志：

```bash
# 应该看到以下日志序列：
[HandoffService] 创建工单：ticketId=xxx, sessionId=xxx
[HandoffQueue] 加入队列：tenantId=1, handoffRequestId=xxx, position=1
[AgentAssigner] 分配客服成功：handoffRequestId=xxx, agentId=xxx, score=xxx
[HandoffService] 已更新会话的客服ID：sessionId=xxx, agentId=xxx  # 新增日志
[HandoffService] 转人工请求通知已发送：agentId=xxx, handoffRequestId=xxx
```

### 2. 数据库验证

查询 `chat_session` 表，确认 `agent_id` 已正确设置：

```sql
SELECT id, tenant_id, user_id, agent_id, chat_mode, handoff_request_id 
FROM chat_session 
WHERE id = xxx;
```

预期结果：
- `agent_id`: 应该有值（不为 null）
- `chat_mode`: AGENT
- `handoff_request_id`: 应该有值

### 3. 前端验证

1. **用户端**：
   - 点击"转人工"按钮
   - 应该看到"排队中"提示
   - 等待1-2秒后，应该收到"客服已接入"通知
   - 可以正常发送消息

2. **客服端**：
   - 打开客服工作台
   - 应该在"待处理请求"列表中看到新的转人工请求
   - 点击"接受"按钮
   - 应该能看到会话窗口，并能正常收发消息

## 其他优化建议

### 1. 添加超时处理

如果客服长时间未接受请求，应该：
- 自动转为工单
- 通知用户
- 释放排队资源

### 2. 添加重试机制

如果分配客服失败，应该：
- 重新进入队列
- 尝试分配其他客服
- 记录失败原因

### 3. 优化 WebSocket 并发

当前 WebSocket 发送消息时可能出现并发问题（`TEXT_PARTIAL_WRITING` 错误），建议：
- 添加消息队列
- 使用同步锁
- 或者使用 `synchronized` 方法

### 4. 添加前端轮询兜底

如果 WebSocket 连接不稳定，建议：
- 添加定时轮询机制
- 定期查询转人工状态
- 确保用户能及时收到通知

## 总结

本次修复的核心是**确保 `ChatSession` 的 `agent_id` 字段在分配客服时被正确更新**。这是一个典型的"状态同步"问题，在分布式系统中需要特别注意多个数据表之间的状态一致性。

修复后，转人工功能应该能够正常工作：
1. ✅ 用户申请转人工
2. ✅ 系统分配客服
3. ✅ 客服收到通知
4. ✅ 客服接受请求
5. ✅ 双方正常通信
