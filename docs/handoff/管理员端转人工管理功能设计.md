# 管理员端转人工管理功能设计

> 基于当前 Handoff 实现（`src/main/java/com/ityfz/yulu/handoff/**`）的扩展设计，仅新增管理员视角的查询与管理能力，不修改现有用户端 / 客服端逻辑。

---

## 一、功能目标

在当前 C 端（用户）与 B 端（客服）转人工闭环已实现的基础上，为管理员（Admin）提供一套“可观测 + 可干预”的后台能力，主要包括：

1. **转人工记录管理**
   - 按多维条件查询所有 `handoff_request` 记录。
   - 查看单次转人工的完整生命周期（事件时间轴）。
   - 支持统计分析：数量、成功率、响应时长等。

2. **客服在线状态与会话监控**
   - 实时查看所有客服的在线状态（在线/离开/离线）及当前会话数。
   - 支持管理员强制调整客服状态（如强制下线），保障路由策略合理性。

3. **转人工通知与运营广播**
   - 管理员可向某租户/全体客服发送系统通知，例如维护公告、运营提醒。
   - 通知通过 WebSocket 实时送达客服工作台。

> 设计原则：**只读优先，最小侵入**。除必要的“强制状态调整”和“广播通知”外，其余操作以查询与展示为主，避免与一线业务逻辑耦合。

---

## 二、整体架构

在现有架构基础上新增一层 **Admin 管理视图**：

- **现有层级**：
  - C 端：`CustomerHandoffController` + WebSocket(`CustomerWebSocketHandler`)
  - B 端：`AgentHandoffController` + WebSocket(`AgentWebSocketHandler`)
  - 核心：`HandoffService` + `HandoffRequest` / `HandoffEvent` / 队列 / 工单

- **新增层级（Admin）**：
  - Admin API：`AdminHandoffController`（建议路径 `/api/admin/handoff/**`）
  - Admin Service：`AdminHandoffService` / `AdminAgentManagementService`
  - WebSocket 广播：复用 `AgentWebSocketHandler`，新增广播型接口

数据流上：

- 查询类接口（Records/Events/Stats）直接读取 `handoff_request` 和 `handoff_event`，只读，不改主业务流程。
- 实时状态相关接口（在线状态）读取 / 修改 `AgentStatusService` 管理的 Redis/DB 状态，并通过 WS 通知前端刷新。

---

## 三、数据模型复用与新视图

### 3.1 复用现有表

1. **`handoff_request`（HandoffRequest）**
   - 记录每次转人工请求的核心信息：租户、会话、用户、客服、工单、状态、优先级、时间戳。
   - 管理员查询列表、统计分析的主数据源。

2. **`handoff_event`（HandoffEvent）**
   - 记录事件流水：CREATED / ASSIGNED / ACCEPTED / COMPLETED / CANCELLED / FALLBACK_TICKET 等。
   - 管理员查看单条转人工的“时间轴”的数据源。

3. **其他表（只读）**
   - `chat_session`：可以按需加入会话标题、最近消息时间等辅助字段。
   - `ticket`：补充工单优先级、标签等信息。

### 3.2 新增视图对象（VO / DTO）

建议新增以下 DTO/VO（仅为说明，不强制实现）：

- `HandoffRecordQueryDTO`：管理员端查询条件
  - `tenantId`、`userId`、`agentId`、`status`、`startTime`、`endTime`、分页参数

- `HandoffRecordVO`：列表展示字段
  - `handoffRequestId`、`tenantId`、`tenantName`
  - `sessionId`、`sessionTitle`
  - `userId`、`userName`
  - `agentId`、`agentName`
  - `ticketId`、`ticketStatus`
  - `status`、`priority`
  - `createdAt`、`assignedAt`、`acceptedAt`、`completedAt`
  - `duration`（例如：从 ACCEPTED 到 COMPLETED 的耗时）

- `HandoffEventVO`：时间轴条目
  - `eventType`、`operatorType`、`operatorId`、`operatorName`、`eventTime`、`eventData`（JSON）

- `AgentMonitorVO`：客服监控条目
  - `agentId`、`userName`、`tenantId`
  - `status`（在线/离线/离开）
  - `currentSessions`（当前会话数）
  - `maxSessions`（配置上限）
  - `lastActiveTime`

---

## 四、管理员端接口设计

### 4.1 转人工记录查询接口

**目标**：按条件分页查询 `handoff_request`，并支持查看时间轴详情。

#### 4.1.1 Controller 设计

```java
@RestController
@RequestMapping("/api/admin/handoff")
@RequireRole("ADMIN")
public class AdminHandoffController {

    private final AdminHandoffService adminHandoffService;

    /**
     * 分页查询转人工记录
     */
    @GetMapping("/records")
    public ApiResponse<PageResult<HandoffRecordVO>> getHandoffRecords(@Valid HandoffRecordQueryDTO query) {
        return ApiResponse.success(adminHandoffService.queryRecords(query));
    }

    /**
     * 查看单次转人工的事件时间轴
     */
    @GetMapping("/records/{handoffRequestId}/events")
    public ApiResponse<List<HandoffEventVO>> getHandoffEvents(@PathVariable Long handoffRequestId) {
        return ApiResponse.success(adminHandoffService.getTimeline(handoffRequestId));
    }
}
```

#### 4.1.2 Service 设计思路

```java
@Service
public class AdminHandoffService {

    private final HandoffRequestMapper handoffRequestMapper;
    private final HandoffEventMapper handoffEventMapper;

    public PageResult<HandoffRecordVO> queryRecords(HandoffRecordQueryDTO query) {
        // 1. 组装查询条件（可根据租户、客服、状态、时间范围过滤）
        // 2. 使用 MyBatis Plus 的分页查询 handoff_request
        // 3. 根据需要 LEFT JOIN / 二次查询 ticket / chat_session / user 信息
        // 4. 封装为 HandoffRecordVO 列表，计算耗时等衍生字段
        return pageResult;
    }

    public List<HandoffEventVO> getTimeline(Long handoffRequestId) {
        // 1. 查询 handoff_event，按 createTime 升序
        // 2. 映射到 VO：将 operatorType/operatorId 翻译成人名（可选）
        // 3. 返回给前端用于渲染时间轴
        return eventVoList;
    }
}
```

> 说明：这里不修改现有 Mapper，仅增加新的查询方法或在 Service 中二次组装，保持对现有业务最小侵入。

---

### 4.2 客服在线状态管理接口

**目标**：帮助管理员实时查看客服状态，并在必要时强制调整。

#### 4.2.1 Controller 设计

```java
@RestController
@RequestMapping("/api/admin/agent")
@RequireRole("ADMIN")
public class AdminAgentController {

    private final AdminAgentManagementService adminAgentManagementService;

    /**
     * 实时查询客服状态列表
     */
    @GetMapping("/status")
    public ApiResponse<List<AgentMonitorVO>> listAgentStatus(@RequestParam(required = false) Long tenantId) {
        return ApiResponse.success(adminAgentManagementService.getAgentRealtimeStatus(tenantId));
    }

    /**
     * 管理员强制调整客服状态（如强制下线）
     */
    @PostMapping("/status/{agentId}/force")
    public ApiResponse<Void> forceUpdateStatus(@PathVariable Long agentId,
                                               @RequestBody ForceAgentStatusDTO dto) {
        adminAgentManagementService.forceSetAgentStatus(agentId, dto.getStatus());
        return ApiResponse.success("操作成功");
    }
}
```

#### 4.2.2 Service 设计思路

```java
@Service
public class AdminAgentManagementService {

    private final AgentStatusService agentStatusService;
    private final AgentWebSocketHandler agentWebSocketHandler;

    public List<AgentMonitorVO> getAgentRealtimeStatus(Long tenantId) {
        // 1. 从 DB 查询客服列表（可按租户过滤）
        // 2. 从 AgentStatusService/Redis 读取实时状态和当前会话数
        // 3. 组装为 AgentMonitorVO 列表返回
    }

    public void forceSetAgentStatus(Long agentId, AgentStatusEnum newStatus) {
        // 1. 更新 AgentStatusService / Redis 中的状态
        agentStatusService.updateStatusForAdmin(agentId, newStatus);

        // 2. 通过 WebSocket 通知该客服客户端同步状态
        Map<String, Object> payload = new HashMap<>();
        payload.put("status", newStatus.name());

        WebSocketMessage message = WebSocketMessage.builder()
                .type("ADMIN_FORCE_STATUS")
                .payload(payload)
                .timestamp(LocalDateTime.now().toString())
                .build();

        agentWebSocketHandler.sendToAgent(null, agentId, message); // tenantId 可选
    }
}
```

> 注意：强制下线会影响请求分配策略，建议在 UI 层做二次确认提示，并记录后台操作日志。

---

### 4.3 转人工通知推送接口

**目标**：管理员可以向客服端推送公告或运营通知，例如“系统维护”、“节假日安排”等。

#### 4.3.1 Controller 设计

```java
@RestController
@RequestMapping("/api/admin/notify")
@RequireRole("ADMIN")
public class AdminNotificationController {

    private final WebSocketBroadcastService broadcastService;

    @PostMapping("/agents")
    public ApiResponse<Void> notifyAgents(@RequestBody AdminNotifyDTO dto) {
        broadcastService.broadcastToAgents(dto.getTenantId(), dto.getTitle(), dto.getContent());
        return ApiResponse.success("已发送");
    }
}
```

#### 4.3.2 Service 设计思路

```java
@Service
public class WebSocketBroadcastService {

    private final AgentWebSocketHandler agentWebSocketHandler;

    public void broadcastToAgents(Long tenantId, String title, String content) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("title", title);
        payload.put("content", content);

        WebSocketMessage message = WebSocketMessage.builder()
                .type("ADMIN_NOTIFICATION")
                .payload(payload)
                .timestamp(LocalDateTime.now().toString())
                .build();

        // 若 tenantId 为 null，可约定为全局广播
        agentWebSocketHandler.broadcast(tenantId, message);
    }
}
```

---

## 五、前端页面结构建议（管理员端）

> 下面是页面结构与交互思路，不涉及你当前前端代码的直接修改，只作为实现参考。

### 5.1 转人工记录管理页

- **筛选条件区域**：
  - 时间范围选择器（申请时间）
  - 租户下拉框
  - 客服下拉框
  - 状态选择（PENDING/ASSIGNED/ACCEPTED/COMPLETED/CANCELLED/FALLBACK_TICKET）

- **表格列建议**：
  - 会话 ID / 会话标题
  - 用户 / 客服
  - 租户
  - 当前状态
  - 申请时间 / 接入时间 / 完成时间 / 耗时
  - 是否兜底为工单
  - 操作：查看详情

- **详情抽屉/弹窗**：使用时间轴组件展示 `handoff_event`：
  - 创建 -> 分配 -> 接受 -> 完成/取消/
  - 显示 operatorType/operatorName 与 eventData（如 endedBy=USER）。

### 5.2 客服在线状态看板

- 左侧：按租户分组的客服列表，展示在线状态灯 + 当前会话数。
- 右侧：选中客服的详情：
  - 最近接入记录
  - 当前进行中的会话列表
  - 管理操作：强制下线、设置为“离开”等。

### 5.3 管理员运营通知

- 表单：选择租户（或全部），输入标题 + 正文
- 提交后，通过 WebSocket 推送到客服工作台的通知中心

---

## 六、与现有 Handoff 体系的关系

1. **不改写 `HandoffService` 主流程**：管理员端只读现有 handoff/ticket/chat 数据，不介入转人工业务流转。
2. **复用 WebSocket 通道**：
   - 通过已有 `AgentWebSocketHandler` 扩展新的消息类型（`ADMIN_NOTIFICATION`、`ADMIN_FORCE_STATUS`）即可，无需新建通道。
3. **利用现有多租户概念**：
   - Admin 端可按租户过滤查询，让 SaaS 场景中不同租户的运营人员只看到各自数据。

---

## 七、后续可扩展点

- 加入 **SLAs**：对每个请求计算是否在目标响应时间内被处理。
- 加入 **告警体系**：当排队长度超过阈值、平均等待时间过长时，通过通知或短信告警管理员。
- 引入 **导出功能**：将转人工记录导出为 CSV/Excel 供运营分析使用。

---

## 八、小结

本设计在不修改现有 C 端 / B 端转人工逻辑的前提下，新增了管理员维度的：

- 转人工记录追踪（Records + Timeline）
- 客服在线状态与负载监控（Agent Monitor）
- 转人工相关的运营干预（Notifications）

你可以在此基础上，逐步实现对应的 Controller / Service / 前端页面，形成一个完整的“用户-客服-管理员”闭环客服中台体系。
