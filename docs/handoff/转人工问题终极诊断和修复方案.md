# 转人工问题终极诊断和修复方案

## 当前问题

用户发起转人工请求后，一直显示"排队中"，客服端收不到通知。

## 完整诊断流程

### 步骤1：检查后端服务是否重启

**重要！** 你必须重启后端服务，否则代码修改不会生效。

```bash
# 停止当前服务（Ctrl+C）
# 重新启动
mvn spring-boot:run
```

### 步骤2：检查 Redis 客服状态

使用 Postman 或 curl：

```
GET http://localhost:8080/api/admin/debug/check-agent-redis/3
Headers:
  Authorization: Bearer <管理员token>
```

**预期响应：**
```json
{
  "code": 200,
  "message": "检查完成",
  "data": {
    "statusKeyExists": true,
    "statusKeyType": "HASH",  // 必须是 HASH！
    "statusData": {
      "status": "ONLINE",
      "current_sessions": 0,  // 必须小于 max_sessions
      "max_sessions": 5
    }
  }
}
```

**如果 `statusKeyType` 不是 "HASH"，执行修复：**

```
POST http://localhost:8080/api/admin/debug/force-reset-agent/3
Headers:
  Authorization: Bearer <管理员token>
```

然后客服重新设置在线：

```
PUT http://localhost:8080/api/admin/user/online-status?status=ONLINE
Headers:
  Authorization: Bearer <客服token>
```

### 步骤3：清空排队队列

```
DELETE http://localhost:8080/api/admin/debug/clear-queue
Headers:
  Authorization: Bearer <管理员token>
```

### 步骤4：测试转人工流程

#### 4.1 用户发起转人工请求

用户端点击"转人工"按钮。

#### 4.2 观察后端日志

**应该看到以下日志序列：**

```
[HandoffService] 创建工单：ticketId=xxx, sessionId=xxx
[HandoffQueue] 加入队列：tenantId=1, handoffRequestId=xxx, position=1
[AgentAssigner] 分配客服成功：handoffRequestId=xxx, agentId=3, score=xxx
[HandoffService] 已更新会话的客服ID：sessionId=xxx, agentId=3  ← 关键日志！
[HandoffService] 转人工请求通知已发送：agentId=3, handoffRequestId=xxx
[HandoffService] 客服分配完成：handoffRequestId=xxx, agentId=3, sessionId=xxx
```

**如果没有看到 "已更新会话的客服ID" 这行日志，说明：**
1. 后端服务没有重启
2. 或者分配客服失败了

#### 4.3 查询数据库验证

```sql
-- 查询最新的会话
SELECT id, tenant_id, user_id, agent_id, chat_mode, handoff_request_id, create_time
FROM chat_session
ORDER BY create_time DESC
LIMIT 1;
```

**预期结果：**
- `agent_id`: 应该有值（3），不为 null ✅
- `chat_mode`: AGENT ✅
- `handoff_request_id`: 应该有值 ✅

**如果 `agent_id` 还是 null：**
- 说明后端代码没有生效，需要重启服务

### 步骤5：检查客服端是否收到通知

客服端应该在"待处理请求"列表中看到新的转人工请求。

**如果没有收到：**
1. 检查客服 WebSocket 是否连接
2. 检查后端日志是否有发送通知的日志
3. 检查前端控制台是否有错误

## 完整的 SQL 诊断脚本

```sql
-- 1. 查询最新的转人工请求
SELECT 
    hr.id AS handoff_request_id,
    hr.session_id,
    hr.user_id,
    hr.agent_id,
    hr.status,
    hr.create_time
FROM handoff_request hr
ORDER BY hr.create_time DESC
LIMIT 5;

-- 2. 查询对应的会话
SELECT 
    cs.id AS session_id,
    cs.user_id,
    cs.agent_id,  -- 这个字段应该有值
    cs.chat_mode,
    cs.handoff_request_id,
    cs.create_time
FROM chat_session cs
WHERE cs.id IN (
    SELECT session_id FROM handoff_request ORDER BY create_time DESC LIMIT 5
);

-- 3. 检查会话和请求的 agent_id 是否一致
SELECT 
    cs.id AS session_id,
    cs.agent_id AS session_agent_id,
    hr.id AS handoff_request_id,
    hr.agent_id AS request_agent_id,
    hr.status,
    CASE 
        WHEN cs.agent_id = hr.agent_id THEN '✅ 一致'
        WHEN cs.agent_id IS NULL AND hr.agent_id IS NOT NULL THEN '❌ 会话未更新'
        WHEN cs.agent_id IS NOT NULL AND hr.agent_id IS NULL THEN '❌ 请求未分配'
        ELSE '❌ 不一致'
    END AS consistency_check
FROM chat_session cs
INNER JOIN handoff_request hr ON cs.handoff_request_id = hr.id
WHERE cs.chat_mode = 'AGENT'
ORDER BY cs.create_time DESC
LIMIT 10;
```

## 如果还是不行，手动修复数据库

如果后端代码确实执行了，但是数据库没有更新，可以手动修复：

```sql
-- 查找需要修复的会话
SELECT 
    cs.id AS session_id,
    cs.agent_id AS current_agent_id,
    hr.agent_id AS should_be_agent_id,
    hr.id AS handoff_request_id
FROM chat_session cs
INNER JOIN handoff_request hr ON cs.handoff_request_id = hr.id
WHERE cs.chat_mode = 'AGENT'
  AND cs.agent_id IS NULL
  AND hr.agent_id IS NOT NULL
  AND hr.status IN ('ASSIGNED', 'ACCEPTED', 'IN_PROGRESS');

-- 手动修复（谨慎执行！）
UPDATE chat_session cs
INNER JOIN handoff_request hr ON cs.handoff_request_id = hr.id
SET cs.agent_id = hr.agent_id
WHERE cs.chat_mode = 'AGENT'
  AND cs.agent_id IS NULL
  AND hr.agent_id IS NOT NULL
  AND hr.status IN ('ASSIGNED', 'ACCEPTED', 'IN_PROGRESS');
```

## 终极修复方案：一键重置所有状态

如果以上方法都不行，使用这个终极方案：

### 1. 清理所有 Redis 数据

```redis
# 删除所有客服状态
DEL agent:status:1:3

# 删除所有会话计数
DEL agent:sessions:1:3

# 删除在线集合
DEL agent:online:1

# 删除排队队列
DEL handoff:queue:1
```

### 2. 清理数据库中的未完成请求

```sql
-- 将所有未完成的转人工请求标记为已取消
UPDATE handoff_request
SET status = 'CANCELLED',
    closed_at = NOW()
WHERE tenant_id = 1
  AND status IN ('PENDING', 'ASSIGNED')
  AND create_time < DATE_SUB(NOW(), INTERVAL 1 HOUR);

-- 将所有转人工模式的会话切换回 AI 模式
UPDATE chat_session
SET chat_mode = 'AI',
    agent_id = NULL
WHERE tenant_id = 1
  AND chat_mode = 'AGENT'
  AND agent_id IS NULL;
```

### 3. 重启所有服务

```bash
# 1. 重启后端
# 停止服务（Ctrl+C）
mvn spring-boot:run

# 2. 刷新前端
# 客服端：按 F5 刷新
# 用户端：按 F5 刷新
```

### 4. 客服重新上线

```
PUT http://localhost:8080/api/admin/user/online-status?status=ONLINE
Headers:
  Authorization: Bearer <客服token>
```

### 5. 重新测试

从头开始测试转人工流程。

## 调试技巧

### 技巧1：实时查看后端日志

在后端控制台中，实时观察日志输出。关键日志：

```
[HandoffService] 创建工单
[HandoffQueue] 加入队列
[AgentAssigner] 分配客服成功
[HandoffService] 已更新会话的客服ID  ← 最关键！
[HandoffService] 转人工请求通知已发送
```

### 技巧2：使用 SQL 实时监控

在数据库客户端中，每隔几秒执行一次：

```sql
SELECT 
    cs.id,
    cs.agent_id,
    cs.chat_mode,
    hr.id AS hr_id,
    hr.agent_id AS hr_agent_id,
    hr.status,
    cs.create_time
FROM chat_session cs
LEFT JOIN handoff_request hr ON cs.handoff_request_id = hr.id
WHERE cs.tenant_id = 1
ORDER BY cs.create_time DESC
LIMIT 5;
```

### 技巧3：使用 Redis 监控

在 Redis 客户端中，实时查看：

```redis
# 查看客服状态
HGETALL agent:status:1:3

# 查看排队队列
LRANGE handoff:queue:1 0 -1

# 查看在线客服
ZRANGE agent:online:1 0 -1 WITHSCORES
```

## 常见错误和解决方法

### 错误1：后端日志没有 "已更新会话的客服ID"

**原因**：后端服务没有重启，代码修改没有生效。

**解决**：重启后端服务。

### 错误2：后端日志显示 "没有可接入的客服（负载已满）"

**原因**：Redis 中客服状态错误。

**解决**：
1. 使用 `force-reset-agent` 接口重置
2. 客服重新设置在线

### 错误3：后端日志显示 "未找到可分配的客服"

**原因**：没有客服在线。

**解决**：
1. 检查 Redis：`HGETALL agent:status:1:3`
2. 客服调用设置在线接口

### 错误4：数据库中 agent_id 还是 null

**原因**：
1. 后端代码没有执行
2. 或者事务回滚了

**解决**：
1. 检查后端日志是否有异常
2. 手动执行 SQL 修复

## 最终检查清单

在测试转人工之前，确认以下所有项：

- [ ] 后端服务已重启
- [ ] Redis 客服状态正确（HASH 类型，current_sessions < max_sessions）
- [ ] 排队队列已清空
- [ ] 客服已设置在线状态
- [ ] 客服 WebSocket 已连接
- [ ] 数据库中没有旧的未完成请求

全部确认后，再次测试转人工功能。

## 总结

如果按照以上步骤还是不行，请提供：

1. 完整的后端日志（从用户发起转人工到失败的全部日志）
2. Redis 中 `agent:status:1:3` 的完整内容
3. 数据库查询结果（最新的 chat_session 和 handoff_request）

我会根据这些信息进一步诊断问题。
