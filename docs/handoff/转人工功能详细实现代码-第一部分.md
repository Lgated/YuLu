# è½¬äººå·¥åŠŸèƒ½è¯¦ç»†å®ç°ä»£ç  - ç¬¬ä¸€éƒ¨åˆ†

> **åŒ…å«å†…å®¹**ï¼šå®ä½“ç±»å’ŒMapperã€WebSocketåŸºç¡€è®¾æ–½ã€è½¬äººå·¥æ ¸å¿ƒé€»è¾‘çš„å®Œæ•´ä»£ç 

---

## ğŸ“‹ ç›®å½•

1. [æ•°æ®åº“è¡¨SQL](#æ•°æ®åº“è¡¨sql)
2. [å®ä½“ç±»](#å®ä½“ç±»)
3. [Mapperæ¥å£](#mapperæ¥å£)
4. [DTOç±»](#dtoç±»)
5. [æšä¸¾ç±»](#æšä¸¾ç±»)
6. [WebSocketåŸºç¡€è®¾æ–½](#websocketåŸºç¡€è®¾æ–½)
7. [è½¬äººå·¥æ ¸å¿ƒé€»è¾‘](#è½¬äººå·¥æ ¸å¿ƒé€»è¾‘)
8. [å®ç°æ­¥éª¤](#å®ç°æ­¥éª¤)

---

## ğŸ—„ï¸ æ•°æ®åº“è¡¨SQL

### æ­¥éª¤1ï¼šæ‰§è¡ŒSQLåˆ›å»ºè¡¨

```sql
-- ============================================
-- 1. è½¬äººå·¥è¯·æ±‚è¡¨
-- ============================================
DROP TABLE IF EXISTS `handoff_request`;
CREATE TABLE `handoff_request` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'ä¸»é”®ID',
  `tenant_id` BIGINT(20) NOT NULL COMMENT 'ç§Ÿæˆ·ID',
  `session_id` BIGINT(20) NOT NULL COMMENT 'ä¼šè¯ID',
  `user_id` BIGINT(20) NOT NULL COMMENT 'å®¢æˆ·ID',
  `ticket_id` BIGINT(20) DEFAULT NULL COMMENT 'å…³è”å·¥å•IDï¼ˆè½¬äººå·¥æ—¶è‡ªåŠ¨åˆ›å»º/å…³è”ï¼‰',
  `agent_id` BIGINT(20) DEFAULT NULL COMMENT 'åˆ†é…çš„å®¢æœID',
  `status` VARCHAR(20) NOT NULL DEFAULT 'PENDING' COMMENT 'çŠ¶æ€ï¼šPENDING-æ’é˜Ÿä¸­ï¼ŒASSIGNED-å·²åˆ†é…ï¼ŒACCEPTED-å·²æ¥å—ï¼ŒIN_PROGRESS-è¿›è¡Œä¸­ï¼ŒCOMPLETED-å·²å®Œæˆï¼ŒCLOSED-å·²å…³é—­ï¼ŒREJECTED-å·²æ‹’ç»',
  `priority` VARCHAR(20) NOT NULL DEFAULT 'MEDIUM' COMMENT 'ä¼˜å…ˆçº§ï¼šLOW-ä½ï¼ŒMEDIUM-ä¸­ï¼ŒHIGH-é«˜ï¼ŒURGENT-ç´§æ€¥',
  `reason` VARCHAR(500) DEFAULT NULL COMMENT 'è½¬äººå·¥åŸå› ï¼ˆå®¢æˆ·å¡«å†™ï¼‰',
  `queue_position` INT(11) DEFAULT NULL COMMENT 'æ’é˜Ÿä½ç½®',
  `assigned_at` DATETIME DEFAULT NULL COMMENT 'åˆ†é…æ—¶é—´',
  `accepted_at` DATETIME DEFAULT NULL COMMENT 'å®¢æœæ¥å—æ—¶é—´',
  `started_at` DATETIME DEFAULT NULL COMMENT 'å¯¹è¯å¼€å§‹æ—¶é—´',
  `completed_at` DATETIME DEFAULT NULL COMMENT 'å¯¹è¯å®Œæˆæ—¶é—´',
  `closed_at` DATETIME DEFAULT NULL COMMENT 'å…³é—­æ—¶é—´',
  `reject_reason` VARCHAR(500) DEFAULT NULL COMMENT 'æ‹’ç»åŸå› ï¼ˆå¦‚æœå®¢æœæ‹’ç»ï¼‰',
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
  `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'æ›´æ–°æ—¶é—´',
  PRIMARY KEY (`id`),
  KEY `idx_tenant_id` (`tenant_id`),
  KEY `idx_session_id` (`session_id`),
  KEY `idx_ticket_id` (`ticket_id`),
  KEY `idx_agent_id` (`agent_id`),
  KEY `idx_status` (`status`),
  KEY `idx_tenant_status` (`tenant_id`, `status`),
  KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='è½¬äººå·¥è¯·æ±‚è¡¨';

-- ============================================
-- 2. è½¬äººå·¥äº‹ä»¶è®°å½•è¡¨ï¼ˆå®¡è®¡ç”¨ï¼Œå¯é€‰ï¼‰
-- ============================================
DROP TABLE IF EXISTS `handoff_event`;
CREATE TABLE `handoff_event` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'ä¸»é”®ID',
  `tenant_id` BIGINT(20) NOT NULL COMMENT 'ç§Ÿæˆ·ID',
  `handoff_request_id` BIGINT(20) NOT NULL COMMENT 'è½¬äººå·¥è¯·æ±‚ID',
  `event_type` VARCHAR(50) NOT NULL COMMENT 'äº‹ä»¶ç±»å‹ï¼šCREATED-åˆ›å»ºï¼ŒASSIGNED-åˆ†é…ï¼ŒACCEPTED-æ¥å—ï¼ŒREJECTED-æ‹’ç»ï¼ŒSTARTED-å¼€å§‹ï¼ŒCOMPLETED-å®Œæˆï¼ŒCLOSED-å…³é—­',
  `event_data` TEXT COMMENT 'äº‹ä»¶æ•°æ®ï¼ˆJSONæ ¼å¼ï¼Œå­˜å‚¨è¯¦ç»†ä¿¡æ¯ï¼‰',
  `operator_id` BIGINT(20) DEFAULT NULL COMMENT 'æ“ä½œäººIDï¼ˆå®¢æˆ·æˆ–å®¢æœï¼‰',
  `operator_type` VARCHAR(20) DEFAULT NULL COMMENT 'æ“ä½œäººç±»å‹ï¼šUSER-å®¢æˆ·ï¼ŒAGENT-å®¢æœï¼ŒSYSTEM-ç³»ç»Ÿ',
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
  PRIMARY KEY (`id`),
  KEY `idx_handoff_request_id` (`handoff_request_id`),
  KEY `idx_tenant_id` (`tenant_id`),
  KEY `idx_event_type` (`event_type`),
  KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='è½¬äººå·¥äº‹ä»¶è®°å½•è¡¨';

-- ============================================
-- 3. æ‰©å±• chat_session è¡¨
-- ============================================
ALTER TABLE `chat_session` 
ADD COLUMN `handoff_request_id` BIGINT(20) DEFAULT NULL COMMENT 'è½¬äººå·¥è¯·æ±‚ID' AFTER `status`,
ADD COLUMN `agent_id` BIGINT(20) DEFAULT NULL COMMENT 'å½“å‰æ¥å…¥çš„å®¢æœID' AFTER `handoff_request_id`,
ADD COLUMN `chat_mode` VARCHAR(20) NOT NULL DEFAULT 'AI' COMMENT 'å¯¹è¯æ¨¡å¼ï¼šAI-AIå¯¹è¯ï¼ŒAGENT-äººå·¥å®¢æœå¯¹è¯' AFTER `agent_id`,
ADD KEY `idx_handoff_request_id` (`handoff_request_id`),
ADD KEY `idx_agent_id` (`agent_id`),
ADD KEY `idx_chat_mode` (`chat_mode`);
```

---

## ğŸ“¦ å®ä½“ç±»

### 1. HandoffRequest å®ä½“ç±»

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/entity/HandoffRequest.java`

```java
package com.ityfz.yulu.handoff.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;

import java.time.LocalDateTime;

/**
 * è½¬äººå·¥è¯·æ±‚å®ä½“ç±»
 */
@Data
@TableName("handoff_request")
public class HandoffRequest {
    
    /**
     * ä¸»é”®ID
     */
    @TableId(type = IdType.AUTO)
    private Long id;
    
    /**
     * ç§Ÿæˆ·ID
     */
    private Long tenantId;
    
    /**
     * ä¼šè¯ID
     */
    private Long sessionId;
    
    /**
     * å®¢æˆ·ID
     */
    private Long userId;
    
    /**
     * å…³è”å·¥å•IDï¼ˆè½¬äººå·¥æ—¶è‡ªåŠ¨åˆ›å»º/å…³è”ï¼‰
     */
    private Long ticketId;
    
    /**
     * åˆ†é…çš„å®¢æœID
     */
    private Long agentId;
    
    /**
     * çŠ¶æ€ï¼šPENDING-æ’é˜Ÿä¸­ï¼ŒASSIGNED-å·²åˆ†é…ï¼ŒACCEPTED-å·²æ¥å—ï¼ŒIN_PROGRESS-è¿›è¡Œä¸­ï¼ŒCOMPLETED-å·²å®Œæˆï¼ŒCLOSED-å·²å…³é—­ï¼ŒREJECTED-å·²æ‹’ç»
     */
    private String status;
    
    /**
     * ä¼˜å…ˆçº§ï¼šLOW-ä½ï¼ŒMEDIUM-ä¸­ï¼ŒHIGH-é«˜ï¼ŒURGENT-ç´§æ€¥
     */
    private String priority;
    
    /**
     * è½¬äººå·¥åŸå› ï¼ˆå®¢æˆ·å¡«å†™ï¼‰
     */
    private String reason;
    
    /**
     * æ’é˜Ÿä½ç½®
     */
    private Integer queuePosition;
    
    /**
     * åˆ†é…æ—¶é—´
     */
    private LocalDateTime assignedAt;
    
    /**
     * å®¢æœæ¥å—æ—¶é—´
     */
    private LocalDateTime acceptedAt;
    
    /**
     * å¯¹è¯å¼€å§‹æ—¶é—´
     */
    private LocalDateTime startedAt;
    
    /**
     * å¯¹è¯å®Œæˆæ—¶é—´
     */
    private LocalDateTime completedAt;
    
    /**
     * å…³é—­æ—¶é—´
     */
    private LocalDateTime closedAt;
    
    /**
     * æ‹’ç»åŸå› ï¼ˆå¦‚æœå®¢æœæ‹’ç»ï¼‰
     */
    private String rejectReason;
    
    /**
     * åˆ›å»ºæ—¶é—´
     */
    private LocalDateTime createTime;
    
    /**
     * æ›´æ–°æ—¶é—´
     */
    private LocalDateTime updateTime;
}
```

### 2. HandoffEvent å®ä½“ç±»ï¼ˆå¯é€‰ï¼Œç”¨äºå®¡è®¡ï¼‰

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/entity/HandoffEvent.java`

```java
package com.ityfz.yulu.handoff.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;

import java.time.LocalDateTime;

/**
 * è½¬äººå·¥äº‹ä»¶è®°å½•å®ä½“ç±»ï¼ˆç”¨äºå®¡è®¡ï¼‰
 */
@Data
@TableName("handoff_event")
public class HandoffEvent {
    
    /**
     * ä¸»é”®ID
     */
    @TableId(type = IdType.AUTO)
    private Long id;
    
    /**
     * ç§Ÿæˆ·ID
     */
    private Long tenantId;
    
    /**
     * è½¬äººå·¥è¯·æ±‚ID
     */
    private Long handoffRequestId;
    
    /**
     * äº‹ä»¶ç±»å‹ï¼šCREATED-åˆ›å»ºï¼ŒASSIGNED-åˆ†é…ï¼ŒACCEPTED-æ¥å—ï¼ŒREJECTED-æ‹’ç»ï¼ŒSTARTED-å¼€å§‹ï¼ŒCOMPLETED-å®Œæˆï¼ŒCLOSED-å…³é—­
     */
    private String eventType;
    
    /**
     * äº‹ä»¶æ•°æ®ï¼ˆJSONæ ¼å¼ï¼Œå­˜å‚¨è¯¦ç»†ä¿¡æ¯ï¼‰
     */
    private String eventData;
    
    /**
     * æ“ä½œäººIDï¼ˆå®¢æˆ·æˆ–å®¢æœï¼‰
     */
    private Long operatorId;
    
    /**
     * æ“ä½œäººç±»å‹ï¼šUSER-å®¢æˆ·ï¼ŒAGENT-å®¢æœï¼ŒSYSTEM-ç³»ç»Ÿ
     */
    private String operatorType;
    
    /**
     * åˆ›å»ºæ—¶é—´
     */
    private LocalDateTime createTime;
}
```

---

## ğŸ”Œ Mapperæ¥å£

### 1. HandoffRequestMapper

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/mapper/HandoffRequestMapper.java`

```java
package com.ityfz.yulu.handoff.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.ityfz.yulu.handoff.entity.HandoffRequest;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/**
 * è½¬äººå·¥è¯·æ±‚Mapperæ¥å£
 */
@Mapper
public interface HandoffRequestMapper extends BaseMapper<HandoffRequest> {
    
    /**
     * æŸ¥è¯¢æŒ‡å®šä¼šè¯çš„æœªå®Œæˆè½¬äººå·¥è¯·æ±‚
     */
    @Select("SELECT * FROM handoff_request WHERE session_id = #{sessionId} " +
            "AND status NOT IN ('COMPLETED', 'CLOSED') ORDER BY create_time DESC LIMIT 1")
    HandoffRequest selectUncompletedBySessionId(@Param("sessionId") Long sessionId);
    
    /**
     * æŸ¥è¯¢æŒ‡å®šå®¢æœçš„å¾…å¤„ç†è½¬äººå·¥è¯·æ±‚
     */
    @Select("SELECT * FROM handoff_request WHERE tenant_id = #{tenantId} " +
            "AND agent_id = #{agentId} AND status = 'ASSIGNED' ORDER BY create_time ASC")
    List<HandoffRequest> selectPendingByAgentId(@Param("tenantId") Long tenantId, 
                                                 @Param("agentId") Long agentId);
    
    /**
     * æŸ¥è¯¢æŒ‡å®šç§Ÿæˆ·çš„æ’é˜Ÿä¸­è¯·æ±‚æ•°é‡
     */
    @Select("SELECT COUNT(*) FROM handoff_request WHERE tenant_id = #{tenantId} " +
            "AND status = 'PENDING'")
    Long countPendingByTenantId(@Param("tenantId") Long tenantId);
}
```

### 2. HandoffEventMapper

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/mapper/HandoffEventMapper.java`

```java
package com.ityfz.yulu.handoff.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.ityfz.yulu.handoff.entity.HandoffEvent;
import org.apache.ibatis.annotations.Mapper;

/**
 * è½¬äººå·¥äº‹ä»¶è®°å½•Mapperæ¥å£
 */
@Mapper
public interface HandoffEventMapper extends BaseMapper<HandoffEvent> {
}
```

---

## ğŸ“ DTOç±»

### 1. è½¬äººå·¥ç”³è¯·è¯·æ±‚DTO

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/dto/HandoffTransferRequest.java`

```java
package com.ityfz.yulu.handoff.dto;

import lombok.Data;

import javax.validation.constraints.NotNull;

/**
 * è½¬äººå·¥ç”³è¯·è¯·æ±‚DTO
 */
@Data
public class HandoffTransferRequest {
    
    /**
     * ä¼šè¯ID
     */
    @NotNull(message = "ä¼šè¯IDä¸èƒ½ä¸ºç©º")
    private Long sessionId;
    
    /**
     * è½¬äººå·¥åŸå› ï¼ˆå¯é€‰ï¼‰
     */
    private String reason;
}
```

### 2. è½¬äººå·¥ç”³è¯·å“åº”DTO

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/dto/HandoffTransferResponse.java`

```java
package com.ityfz.yulu.handoff.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * è½¬äººå·¥ç”³è¯·å“åº”DTO
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class HandoffTransferResponse {
    
    /**
     * è½¬äººå·¥è¯·æ±‚ID
     */
    private Long handoffRequestId;
    
    /**
     * å…³è”å·¥å•ID
     */
    private Long ticketId;
    
    /**
     * æ’é˜Ÿä½ç½®
     */
    private Integer queuePosition;
    
    /**
     * é¢„è®¡ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰
     */
    private Integer estimatedWaitTime;
}
```

### 3. è½¬äººå·¥çŠ¶æ€æŸ¥è¯¢å“åº”DTO

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/dto/HandoffStatusResponse.java`

```java
package com.ityfz.yulu.handoff.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * è½¬äººå·¥çŠ¶æ€æŸ¥è¯¢å“åº”DTO
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class HandoffStatusResponse {
    
    /**
     * è½¬äººå·¥è¯·æ±‚ID
     */
    private Long handoffRequestId;
    
    /**
     * çŠ¶æ€
     */
    private String status;
    
    /**
     * æ’é˜Ÿä½ç½®
     */
    private Integer queuePosition;
    
    /**
     * é¢„è®¡ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰
     */
    private Integer estimatedWaitTime;
    
    /**
     * åˆ†é…çš„å®¢æœID
     */
    private Long assignedAgentId;
    
    /**
     * åˆ†é…çš„å®¢æœåç§°
     */
    private String assignedAgentName;
}
```

### 4. å®¢æœæ¥å—/æ‹’ç»è¯·æ±‚DTO

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/dto/HandoffAcceptRequest.java`

```java
package com.ityfz.yulu.handoff.dto;

import lombok.Data;

import javax.validation.constraints.NotNull;

/**
 * å®¢æœæ¥å—è½¬äººå·¥è¯·æ±‚DTO
 */
@Data
public class HandoffAcceptRequest {
    
    /**
     * è½¬äººå·¥è¯·æ±‚ID
     */
    @NotNull(message = "è½¬äººå·¥è¯·æ±‚IDä¸èƒ½ä¸ºç©º")
    private Long handoffRequestId;
}
```

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/dto/HandoffRejectRequest.java`

```java
package com.ityfz.yulu.handoff.dto;

import lombok.Data;

import javax.validation.constraints.NotNull;

/**
 * å®¢æœæ‹’ç»è½¬äººå·¥è¯·æ±‚DTO
 */
@Data
public class HandoffRejectRequest {
    
    /**
     * è½¬äººå·¥è¯·æ±‚ID
     */
    @NotNull(message = "è½¬äººå·¥è¯·æ±‚IDä¸èƒ½ä¸ºç©º")
    private Long handoffRequestId;
    
    /**
     * æ‹’ç»åŸå› ï¼ˆå¯é€‰ï¼‰
     */
    private String reason;
}
```

### 5. å®¢æœæ¥å—å“åº”DTO

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/dto/HandoffAcceptResponse.java`

```java
package com.ityfz.yulu.handoff.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * å®¢æœæ¥å—è½¬äººå·¥å“åº”DTO
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class HandoffAcceptResponse {
    
    /**
     * è½¬äººå·¥è¯·æ±‚ID
     */
    private Long handoffRequestId;
    
    /**
     * ä¼šè¯ID
     */
    private Long sessionId;
    
    /**
     * å®¢æˆ·ID
     */
    private Long userId;
    
    /**
     * å·¥å•ID
     */
    private Long ticketId;
}
```

### 6. è½¬äººå·¥è¯·æ±‚åˆ—è¡¨é¡¹DTO

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/dto/HandoffRequestItemDTO.java`

```java
package com.ityfz.yulu.handoff.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * è½¬äººå·¥è¯·æ±‚åˆ—è¡¨é¡¹DTO
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class HandoffRequestItemDTO {
    
    /**
     * è½¬äººå·¥è¯·æ±‚ID
     */
    private Long handoffRequestId;
    
    /**
     * ä¼šè¯ID
     */
    private Long sessionId;
    
    /**
     * å®¢æˆ·ID
     */
    private Long userId;
    
    /**
     * å®¢æˆ·åç§°
     */
    private String userName;
    
    /**
     * å·¥å•ID
     */
    private Long ticketId;
    
    /**
     * å·¥å•æ ‡é¢˜
     */
    private String ticketTitle;
    
    /**
     * ä¼˜å…ˆçº§
     */
    private String priority;
    
    /**
     * è½¬äººå·¥åŸå› 
     */
    private String reason;
    
    /**
     * æ’é˜Ÿä½ç½®
     */
    private Integer queuePosition;
    
    /**
     * åˆ›å»ºæ—¶é—´
     */
    private LocalDateTime createdAt;
}
```

---

## ğŸ”¢ æšä¸¾ç±»

### 1. è½¬äººå·¥çŠ¶æ€æšä¸¾

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/enums/HandoffStatus.java`

```java
package com.ityfz.yulu.handoff.enums;

/**
 * è½¬äººå·¥çŠ¶æ€æšä¸¾
 */
public enum HandoffStatus {
    
    /**
     * æ’é˜Ÿä¸­
     */
    PENDING("PENDING", "æ’é˜Ÿä¸­"),
    
    /**
     * å·²åˆ†é…ï¼ˆç­‰å¾…å®¢æœæ¥å—ï¼‰
     */
    ASSIGNED("ASSIGNED", "å·²åˆ†é…"),
    
    /**
     * å·²æ¥å—ï¼ˆå®¢æœå·²æ¥å—ï¼‰
     */
    ACCEPTED("ACCEPTED", "å·²æ¥å—"),
    
    /**
     * è¿›è¡Œä¸­ï¼ˆå¯¹è¯è¿›è¡Œä¸­ï¼‰
     */
    IN_PROGRESS("IN_PROGRESS", "è¿›è¡Œä¸­"),
    
    /**
     * å·²å®Œæˆ
     */
    COMPLETED("COMPLETED", "å·²å®Œæˆ"),
    
    /**
     * å·²å…³é—­
     */
    CLOSED("CLOSED", "å·²å…³é—­"),
    
    /**
     * å·²æ‹’ç»ï¼ˆå®¢æœæ‹’ç»ï¼‰
     */
    REJECTED("REJECTED", "å·²æ‹’ç»");
    
    private final String code;
    private final String desc;
    
    HandoffStatus(String code, String desc) {
        this.code = code;
        this.desc = desc;
    }
    
    public String getCode() {
        return code;
    }
    
    public String getDesc() {
        return desc;
    }
    
    /**
     * æ ¹æ®codeè·å–æšä¸¾
     */
    public static HandoffStatus fromCode(String code) {
        if (code == null) {
            return null;
        }
        for (HandoffStatus status : values()) {
            if (status.code.equalsIgnoreCase(code)) {
                return status;
            }
        }
        return null;
    }
    
    /**
     * åˆ¤æ–­æ˜¯å¦ä¸ºæœ‰æ•ˆçŠ¶æ€
     */
    public static boolean isValid(String code) {
        return fromCode(code) != null;
    }
    
    /**
     * åˆ¤æ–­æ˜¯å¦ä¸ºå·²å®ŒæˆçŠ¶æ€ï¼ˆåŒ…æ‹¬å·²å®Œæˆå’Œå·²å…³é—­ï¼‰
     */
    public static boolean isCompleted(String code) {
        return COMPLETED.getCode().equals(code) || CLOSED.getCode().equals(code);
    }
}
```

### 2. è½¬äººå·¥äº‹ä»¶ç±»å‹æšä¸¾

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/enums/HandoffEventType.java`

```java
package com.ityfz.yulu.handoff.enums;

/**
 * è½¬äººå·¥äº‹ä»¶ç±»å‹æšä¸¾
 */
public enum HandoffEventType {
    
    /**
     * åˆ›å»º
     */
    CREATED("CREATED", "åˆ›å»º"),
    
    /**
     * åˆ†é…
     */
    ASSIGNED("ASSIGNED", "åˆ†é…"),
    
    /**
     * æ¥å—
     */
    ACCEPTED("ACCEPTED", "æ¥å—"),
    
    /**
     * æ‹’ç»
     */
    REJECTED("REJECTED", "æ‹’ç»"),
    
    /**
     * å¼€å§‹
     */
    STARTED("STARTED", "å¼€å§‹"),
    
    /**
     * å®Œæˆ
     */
    COMPLETED("COMPLETED", "å®Œæˆ"),
    
    /**
     * å…³é—­
     */
    CLOSED("CLOSED", "å…³é—­");
    
    private final String code;
    private final String desc;
    
    HandoffEventType(String code, String desc) {
        this.code = code;
        this.desc = desc;
    }
    
    public String getCode() {
        return code;
    }
    
    public String getDesc() {
        return desc;
    }
}
```

### 3. æ“ä½œäººç±»å‹æšä¸¾

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/enums/OperatorType.java`

```java
package com.ityfz.yulu.handoff.enums;

/**
 * æ“ä½œäººç±»å‹æšä¸¾
 */
public enum OperatorType {
    
    /**
     * å®¢æˆ·
     */
    USER("USER", "å®¢æˆ·"),
    
    /**
     * å®¢æœ
     */
    AGENT("AGENT", "å®¢æœ"),
    
    /**
     * ç³»ç»Ÿ
     */
    SYSTEM("SYSTEM", "ç³»ç»Ÿ");
    
    private final String code;
    private final String desc;
    
    OperatorType(String code, String desc) {
        this.code = code;
        this.desc = desc;
    }
    
    public String getCode() {
        return code;
    }
    
    public String getDesc() {
        return desc;
    }
}
```

---

## ğŸ”Œ WebSocketåŸºç¡€è®¾æ–½

### 1. æ·»åŠ WebSocketä¾èµ–

**æ–‡ä»¶è·¯å¾„**ï¼š`pom.xml`ï¼ˆåœ¨ç°æœ‰dependenciesä¸­æ·»åŠ ï¼‰

```xml
<!-- WebSocketæ”¯æŒ -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

### 2. WebSocketé…ç½®ç±»

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/common/config/WebSocketConfig.java`

```java
package com.ityfz.yulu.common.config;

import com.ityfz.yulu.handoff.websocket.AgentWebSocketHandler;
import com.ityfz.yulu.handoff.websocket.CustomerWebSocketHandler;
import com.ityfz.yulu.handoff.websocket.WebSocketHandshakeInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

/**
 * WebSocketé…ç½®ç±»
 */
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    
    private final CustomerWebSocketHandler customerWebSocketHandler;
    private final AgentWebSocketHandler agentWebSocketHandler;
    private final WebSocketHandshakeInterceptor handshakeInterceptor;
    
    public WebSocketConfig(CustomerWebSocketHandler customerWebSocketHandler,
                          AgentWebSocketHandler agentWebSocketHandler,
                          WebSocketHandshakeInterceptor handshakeInterceptor) {
        this.customerWebSocketHandler = customerWebSocketHandler;
        this.agentWebSocketHandler = agentWebSocketHandler;
        this.handshakeInterceptor = handshakeInterceptor;
    }
    
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        // å®¢æˆ·WebSocketè¿æ¥
        registry.addHandler(customerWebSocketHandler, "/api/ws/customer")
                .addInterceptors(handshakeInterceptor)
                .setAllowedOrigins("*"); // ç”Ÿäº§ç¯å¢ƒåº”é…ç½®å…·ä½“åŸŸå
        
        // å®¢æœWebSocketè¿æ¥
        registry.addHandler(agentWebSocketHandler, "/api/ws/agent")
                .addInterceptors(handshakeInterceptor)
                .setAllowedOrigins("*");
    }
}
```

### 3. WebSocketæ¡æ‰‹æ‹¦æˆªå™¨ï¼ˆç”¨äºé‰´æƒï¼‰

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/websocket/WebSocketHandshakeInterceptor.java`

```java
package com.ityfz.yulu.handoff.websocket;

import com.ityfz.yulu.common.security.JwtUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.http.server.ServletServerHttpRequest;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.server.HandshakeInterceptor;

import java.util.Map;

/**
 * WebSocketæ¡æ‰‹æ‹¦æˆªå™¨ï¼ˆç”¨äºé‰´æƒï¼‰
 */
@Slf4j
public class WebSocketHandshakeInterceptor implements HandshakeInterceptor {
    
    @Override
    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response,
                                   WebSocketHandler wsHandler, Map<String, Object> attributes) throws Exception {
        if (request instanceof ServletServerHttpRequest) {
            ServletServerHttpRequest servletRequest = (ServletServerHttpRequest) request;
            
            // ä»URLå‚æ•°è·å–token
            String token = servletRequest.getServletRequest().getParameter("token");
            if (token == null || token.isEmpty()) {
                log.warn("[WebSocket] æ¡æ‰‹å¤±è´¥ï¼šç¼ºå°‘token");
                return false;
            }
            
            // éªŒè¯token
            try {
                // JwtUtil.parseToken() è¿”å›çš„æ˜¯ LoginUser å¯¹è±¡ï¼Œä¸æ˜¯ Map
                JwtUtil.LoginUser loginUser = JwtUtil.parseToken(token);
                Long userId = loginUser.getUserId();
                Long tenantId = loginUser.getTenantId();
                String role = loginUser.getRole();
                
                if (userId == null || tenantId == null) {
                    log.warn("[WebSocket] æ¡æ‰‹å¤±è´¥ï¼štokenä¸­ç¼ºå°‘å¿…è¦ä¿¡æ¯");
                    return false;
                }
                
                // å°†ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åˆ°attributesä¸­ï¼Œä¾›WebSocketHandlerä½¿ç”¨
                attributes.put("userId", userId);
                attributes.put("tenantId", tenantId);
                attributes.put("role", role);
                
                // å¦‚æœæ˜¯å®¢æˆ·è¿æ¥ï¼Œè·å–sessionId
                String sessionIdStr = servletRequest.getServletRequest().getParameter("sessionId");
                if (sessionIdStr != null && !sessionIdStr.isEmpty()) {
                    attributes.put("sessionId", Long.parseLong(sessionIdStr));
                }
                
                log.info("[WebSocket] æ¡æ‰‹æˆåŠŸï¼šuserId={}, tenantId={}, role={}", userId, tenantId, role);
                return true;
            } catch (Exception e) {
                log.error("[WebSocket] æ¡æ‰‹å¤±è´¥ï¼štokenéªŒè¯å¤±è´¥", e);
                return false;
            }
        }
        return false;
    }
    
    @Override
    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response,
                               WebSocketHandler wsHandler, Exception exception) {
        // æ¡æ‰‹åçš„å¤„ç†ï¼ˆå¦‚æœéœ€è¦ï¼‰
    }
}
```

### 4. å®¢æˆ·WebSocket Handler

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/websocket/CustomerWebSocketHandler.java`

```java
package com.ityfz.yulu.handoff.websocket;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.ityfz.yulu.handoff.dto.WebSocketMessage;
import com.ityfz.yulu.handoff.websocket.service.WebSocketMessageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * å®¢æˆ·WebSocket Handler
 */
@Slf4j
@Component
public class CustomerWebSocketHandler extends TextWebSocketHandler {

    // å­˜å‚¨å®¢æˆ·è¿æ¥ï¼škey = "customer:{tenantId}:{userId}:{sessionId}"
    private final Map<String, WebSocketSession> customerSessions = new ConcurrentHashMap<>();

    private final ObjectMapper objectMapper = new ObjectMapper();
    private final WebSocketMessageService messageService;

    public CustomerWebSocketHandler(WebSocketMessageService messageService) {
        this.messageService = messageService;
    }

    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        // ä»attributesè·å–ç”¨æˆ·ä¿¡æ¯
        Long userId = (Long) session.getAttributes().get("userId");
        Long tenantId = (Long) session.getAttributes().get("tenantId");
        Long sessionId = (Long) session.getAttributes().get("sessionId");

        if (userId == null || tenantId == null || sessionId == null) {
            log.warn("[WebSocket] å®¢æˆ·è¿æ¥å¤±è´¥ï¼šç¼ºå°‘å¿…è¦å‚æ•°");
            session.close(CloseStatus.BAD_DATA);
            return;
        }

        // å­˜å‚¨è¿æ¥
        String connectionKey = buildConnectionKey(tenantId, userId, sessionId);
        customerSessions.put(connectionKey, session);

        log.info("[WebSocket] å®¢æˆ·è¿æ¥å»ºç«‹ï¼štenantId={}, userId={}, sessionId={}, connectionKey={}",
                tenantId, userId, sessionId, connectionKey);
    }

    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        try {
            // è§£ææ¶ˆæ¯
            WebSocketMessage wsMessage = objectMapper.readValue(message.getPayload(), WebSocketMessage.class);

            // è·å–ç”¨æˆ·ä¿¡æ¯
            Long userId = (Long) session.getAttributes().get("userId");
            Long tenantId = (Long) session.getAttributes().get("tenantId");
            Long sessionId = (Long) session.getAttributes().get("sessionId");

            // å¤„ç†æ¶ˆæ¯
            messageService.handleCustomerMessage(tenantId, userId, sessionId, wsMessage);

        } catch (Exception e) {
            log.error("[WebSocket] å¤„ç†å®¢æˆ·æ¶ˆæ¯å¤±è´¥", e);
            // å‘é€é”™è¯¯æ¶ˆæ¯ç»™å®¢æˆ·
            sendErrorMessage(session, "æ¶ˆæ¯å¤„ç†å¤±è´¥ï¼š" + e.getMessage());
        }
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        // æ¸…ç†è¿æ¥
        Long userId = (Long) session.getAttributes().get("userId");
        Long tenantId = (Long) session.getAttributes().get("tenantId");
        Long sessionId = (Long) session.getAttributes().get("sessionId");

        if (userId != null && tenantId != null && sessionId != null) {
            String connectionKey = buildConnectionKey(tenantId, userId, sessionId);
            customerSessions.remove(connectionKey);
            log.info("[WebSocket] å®¢æˆ·è¿æ¥å…³é—­ï¼šconnectionKey={}, status={}", connectionKey, status);
        }
    }

    /**
     * å‘é€æ¶ˆæ¯ç»™å®¢æˆ·
     */
    public void sendToCustomer(Long tenantId, Long userId, Long sessionId, WebSocketMessage message) {
        String connectionKey = buildConnectionKey(tenantId, userId, sessionId);
        WebSocketSession session = customerSessions.get(connectionKey);

        if (session != null && session.isOpen()) {
            try {
                String json = objectMapper.writeValueAsString(message);
                session.sendMessage(new TextMessage(json));
                log.debug("[WebSocket] å‘é€æ¶ˆæ¯ç»™å®¢æˆ·ï¼šconnectionKey={}, type={}", connectionKey, message.getType());
            } catch (Exception e) {
                log.error("[WebSocket] å‘é€æ¶ˆæ¯ç»™å®¢æˆ·å¤±è´¥ï¼šconnectionKey={}", connectionKey, e);
            }
        } else {
            log.warn("[WebSocket] å®¢æˆ·è¿æ¥ä¸å­˜åœ¨æˆ–å·²å…³é—­ï¼šconnectionKey={}", connectionKey);
        }
    }

    /**
     * æ„å»ºè¿æ¥key
     */
    private String buildConnectionKey(Long tenantId, Long userId, Long sessionId) {
        return "customer:" + tenantId + ":" + userId + ":" + sessionId;
    }

    /**
     * å‘é€é”™è¯¯æ¶ˆæ¯
     */
    private void sendErrorMessage(WebSocketSession session, String errorMsg) {
        try {
            WebSocketMessage errorMessage = WebSocketMessage.builder()
                    .type("ERROR")
                    .payload(Map.of("message", errorMsg))
                    .timestamp(java.time.LocalDateTime.now().toString())
                    .build();
            String json = objectMapper.writeValueAsString(errorMessage);
            session.sendMessage(new TextMessage(json));
        } catch (Exception e) {
            log.error("[WebSocket] å‘é€é”™è¯¯æ¶ˆæ¯å¤±è´¥", e);
        }
    }
}
```

### 5. å®¢æœWebSocket Handler

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/websocket/AgentWebSocketHandler.java`

```java
package com.ityfz.yulu.handoff.websocket;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.ityfz.yulu.handoff.dto.WebSocketMessage;
import com.ityfz.yulu.handoff.websocket.service.WebSocketMessageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * å®¢æœWebSocket Handler
 */
@Slf4j
@Component
public class AgentWebSocketHandler extends TextWebSocketHandler {

    // å­˜å‚¨å®¢æœè¿æ¥ï¼škey = "agent:{tenantId}:{agentId}"
    private final Map<String, WebSocketSession> agentSessions = new ConcurrentHashMap<>();

    private final ObjectMapper objectMapper = new ObjectMapper();
    private final WebSocketMessageService messageService;

    public AgentWebSocketHandler(WebSocketMessageService messageService) {
        this.messageService = messageService;
    }

    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        // ä»attributesè·å–ç”¨æˆ·ä¿¡æ¯
        Long agentId = (Long) session.getAttributes().get("userId");
        Long tenantId = (Long) session.getAttributes().get("tenantId");
        String role = (String) session.getAttributes().get("role");

        if (agentId == null || tenantId == null) {
            log.warn("[WebSocket] å®¢æœè¿æ¥å¤±è´¥ï¼šç¼ºå°‘å¿…è¦å‚æ•°");
            session.close(CloseStatus.BAD_DATA);
            return;
        }

        // éªŒè¯è§’è‰²ï¼ˆå¿…é¡»æ˜¯AGENTæˆ–ADMINï¼‰
        if (!"AGENT".equals(role) && !"ADMIN".equals(role)) {
            log.warn("[WebSocket] å®¢æœè¿æ¥å¤±è´¥ï¼šè§’è‰²ä¸ç¬¦ï¼Œrole={}", role);
            session.close(CloseStatus.NOT_ACCEPTABLE);
            return;
        }

        // å­˜å‚¨è¿æ¥
        String connectionKey = buildConnectionKey(tenantId, agentId);
        agentSessions.put(connectionKey, session);

        log.info("[WebSocket] å®¢æœè¿æ¥å»ºç«‹ï¼štenantId={}, agentId={}, connectionKey={}",
                tenantId, agentId, connectionKey);
    }

    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        try {
            // è§£ææ¶ˆæ¯
            WebSocketMessage wsMessage = objectMapper.readValue(message.getPayload(), WebSocketMessage.class);

            // è·å–ç”¨æˆ·ä¿¡æ¯
            Long agentId = (Long) session.getAttributes().get("userId");
            Long tenantId = (Long) session.getAttributes().get("tenantId");

            // å¤„ç†æ¶ˆæ¯
            messageService.handleAgentMessage(tenantId, agentId, wsMessage);

        } catch (Exception e) {
            log.error("[WebSocket] å¤„ç†å®¢æœæ¶ˆæ¯å¤±è´¥", e);
            // å‘é€é”™è¯¯æ¶ˆæ¯ç»™å®¢æœ
            sendErrorMessage(session, "æ¶ˆæ¯å¤„ç†å¤±è´¥ï¼š" + e.getMessage());
        }
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        // æ¸…ç†è¿æ¥
        Long agentId = (Long) session.getAttributes().get("userId");
        Long tenantId = (Long) session.getAttributes().get("tenantId");

        if (agentId != null && tenantId != null) {
            String connectionKey = buildConnectionKey(tenantId, agentId);
            agentSessions.remove(connectionKey);
            log.info("[WebSocket] å®¢æœè¿æ¥å…³é—­ï¼šconnectionKey={}, status={}", connectionKey, status);
        }
    }

    /**
     * å‘é€æ¶ˆæ¯ç»™å®¢æœ
     */
    public void sendToAgent(Long tenantId, Long agentId, WebSocketMessage message) {
        String connectionKey = buildConnectionKey(tenantId, agentId);
        WebSocketSession session = agentSessions.get(connectionKey);

        if (session != null && session.isOpen()) {
            try {
                String json = objectMapper.writeValueAsString(message);
                session.sendMessage(new TextMessage(json));
                log.debug("[WebSocket] å‘é€æ¶ˆæ¯ç»™å®¢æœï¼šconnectionKey={}, type={}", connectionKey, message.getType());
            } catch (Exception e) {
                log.error("[WebSocket] å‘é€æ¶ˆæ¯ç»™å®¢æœå¤±è´¥ï¼šconnectionKey={}", connectionKey, e);
            }
        } else {
            log.warn("[WebSocket] å®¢æœè¿æ¥ä¸å­˜åœ¨æˆ–å·²å…³é—­ï¼šconnectionKey={}", connectionKey);
        }
    }

    /**
     * æ„å»ºè¿æ¥key
     */
    private String buildConnectionKey(Long tenantId, Long agentId) {
        return "agent:" + tenantId + ":" + agentId;
    }

    /**
     * å‘é€é”™è¯¯æ¶ˆæ¯
     */
    private void sendErrorMessage(WebSocketSession session, String errorMsg) {
        try {
            WebSocketMessage errorMessage = WebSocketMessage.builder()
                    .type("ERROR")
                    .payload(Map.of("message", errorMsg))
                    .timestamp(java.time.LocalDateTime.now().toString())
                    .build();
            String json = objectMapper.writeValueAsString(errorMessage);
            session.sendMessage(new TextMessage(json));
        } catch (Exception e) {
            log.error("[WebSocket] å‘é€é”™è¯¯æ¶ˆæ¯å¤±è´¥", e);
        }
    }
}
```

### 6. WebSocketæ¶ˆæ¯DTO

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/dto/WebSocketMessage.java`

```java
package com.ityfz.yulu.handoff.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

/**
 * WebSocketæ¶ˆæ¯DTO
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class WebSocketMessage {
    
    /**
     * æ¶ˆæ¯ç±»å‹
     */
    private String type;
    
    /**
     * æ¶ˆæ¯è´Ÿè½½
     */
    private Map<String, Object> payload;
    
    /**
     * æ—¶é—´æˆ³
     */
    private String timestamp;
    
    /**
     * è¯·æ±‚IDï¼ˆå¯é€‰ï¼Œç”¨äºè¯·æ±‚-å“åº”åŒ¹é…ï¼‰
     */
    private String requestId;
}
```

### 7. WebSocketæ¶ˆæ¯æœåŠ¡ï¼ˆå¤„ç†æ¶ˆæ¯é€»è¾‘ï¼‰

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/websocket/WebSocketMessageService.java`

```java
package com.ityfz.yulu.handoff.websocket;

import com.ityfz.yulu.chat.entity.ChatMessage;
import com.ityfz.yulu.chat.entity.ChatSession;
import com.ityfz.yulu.chat.mapper.ChatMessageMapper;
import com.ityfz.yulu.chat.mapper.ChatSessionMapper;
import com.ityfz.yulu.common.enums.ErrorCodes;
import com.ityfz.yulu.common.exception.BizException;
import com.ityfz.yulu.handoff.dto.WebSocketMessage;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * WebSocketæ¶ˆæ¯æœåŠ¡
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class WebSocketMessageService {
    
    private final ChatSessionMapper chatSessionMapper;
    private final ChatMessageMapper chatMessageMapper;
    private final CustomerWebSocketHandler customerHandler;
    private final AgentWebSocketHandler agentHandler;
    
    /**
     * å¤„ç†å®¢æˆ·å‘é€çš„æ¶ˆæ¯
     */
    @Transactional
    public void handleCustomerMessage(Long tenantId, Long userId, Long sessionId, WebSocketMessage wsMessage) {
        // 1. éªŒè¯ä¼šè¯
        ChatSession session = chatSessionMapper.selectById(sessionId);
        if (session == null || !session.getTenantId().equals(tenantId) || !session.getUserId().equals(userId)) {
            throw new BizException(ErrorCodes.UNAUTHORIZED, "ä¼šè¯ä¸å­˜åœ¨æˆ–æ— æƒé™");
        }
        
        // 2. éªŒè¯æ˜¯å¦å·²æ¥å…¥å®¢æœ
        if (session.getAgentId() == null || !"AGENT".equals(session.getChatMode())) {
            throw new BizException(ErrorCodes.VALIDATION_ERROR, "å½“å‰ä¼šè¯æœªæ¥å…¥å®¢æœ");
        }
        
        // 3. å¤„ç†ä¸åŒç±»å‹çš„æ¶ˆæ¯
        String messageType = wsMessage.getType();
        Map<String, Object> payload = wsMessage.getPayload();
        
        if ("TEXT".equals(messageType)) {
            // æ–‡æœ¬æ¶ˆæ¯
            String content = (String) payload.get("content");
            if (content == null || content.trim().isEmpty()) {
                throw new BizException(ErrorCodes.VALIDATION_ERROR, "æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º");
            }
            
            // ä¿å­˜æ¶ˆæ¯åˆ°æ•°æ®åº“
            ChatMessage chatMessage = new ChatMessage();
            chatMessage.setTenantId(tenantId);
            chatMessage.setSessionId(sessionId);
            chatMessage.setSenderType("USER");
            chatMessage.setContent(content);
            chatMessage.setCreateTime(LocalDateTime.now());
            chatMessageMapper.insert(chatMessage);
            
            // è½¬å‘ç»™å®¢æœ
            WebSocketMessage forwardMessage = WebSocketMessage.builder()
                    .type("TEXT")
                    .payload(Map.of(
                            "messageId", chatMessage.getId(),
                            "sessionId", sessionId,
                            "content", content,
                            "senderType", "USER"
                    ))
                    .timestamp(LocalDateTime.now().toString())
                    .build();
            agentHandler.sendToAgent(tenantId, session.getAgentId(), forwardMessage);
            
            log.info("[WebSocket] å®¢æˆ·æ¶ˆæ¯å·²è½¬å‘ç»™å®¢æœï¼šsessionId={}, agentId={}", sessionId, session.getAgentId());
        } else if ("TYPING".equals(messageType)) {
            // æ­£åœ¨è¾“å…¥æç¤ºï¼ˆè½¬å‘ç»™å®¢æœï¼‰
            WebSocketMessage typingMessage = WebSocketMessage.builder()
                    .type("TYPING")
                    .payload(Map.of("sessionId", sessionId))
                    .timestamp(LocalDateTime.now().toString())
                    .build();
            agentHandler.sendToAgent(tenantId, session.getAgentId(), typingMessage);
        }
    }
    
    /**
     * å¤„ç†å®¢æœå‘é€çš„æ¶ˆæ¯
     */
    @Transactional
    public void handleAgentMessage(Long tenantId, Long agentId, WebSocketMessage wsMessage) {
        Map<String, Object> payload = wsMessage.getPayload();
        Long sessionId = Long.valueOf(payload.get("sessionId").toString());
        
        // 1. éªŒè¯ä¼šè¯
        ChatSession session = chatSessionMapper.selectById(sessionId);
        if (session == null || !session.getTenantId().equals(tenantId)) {
            throw new BizException(ErrorCodes.UNAUTHORIZED, "ä¼šè¯ä¸å­˜åœ¨æˆ–æ— æƒé™");
        }
        
        // 2. éªŒè¯å®¢æœæƒé™
        if (!agentId.equals(session.getAgentId())) {
            throw new BizException(ErrorCodes.FORBIDDEN, "æ— æƒé™æ“ä½œæ­¤ä¼šè¯");
        }
        
        // 3. å¤„ç†ä¸åŒç±»å‹çš„æ¶ˆæ¯
        String messageType = wsMessage.getType();
        
        if ("TEXT".equals(messageType)) {
            // æ–‡æœ¬æ¶ˆæ¯
            String content = (String) payload.get("content");
            if (content == null || content.trim().isEmpty()) {
                throw new BizException(ErrorCodes.VALIDATION_ERROR, "æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º");
            }
            
            // ä¿å­˜æ¶ˆæ¯åˆ°æ•°æ®åº“
            ChatMessage chatMessage = new ChatMessage();
            chatMessage.setTenantId(tenantId);
            chatMessage.setSessionId(sessionId);
            chatMessage.setSenderType("AGENT");
            chatMessage.setContent(content);
            chatMessage.setCreateTime(LocalDateTime.now());
            chatMessageMapper.insert(chatMessage);
            
            // è½¬å‘ç»™å®¢æˆ·
            WebSocketMessage forwardMessage = WebSocketMessage.builder()
                    .type("TEXT")
                    .payload(Map.of(
                            "messageId", chatMessage.getId(),
                            "sessionId", sessionId,
                            "content", content,
                            "senderType", "AGENT"
                    ))
                    .timestamp(LocalDateTime.now().toString())
                    .build();
            customerHandler.sendToCustomer(tenantId, session.getUserId(), sessionId, forwardMessage);
            
            log.info("[WebSocket] å®¢æœæ¶ˆæ¯å·²è½¬å‘ç»™å®¢æˆ·ï¼šsessionId={}, userId={}", sessionId, session.getUserId());
        } else if ("TYPING".equals(messageType)) {
            // æ­£åœ¨è¾“å…¥æç¤ºï¼ˆè½¬å‘ç»™å®¢æˆ·ï¼‰
            WebSocketMessage typingMessage = WebSocketMessage.builder()
                    .type("TYPING")
                    .payload(Map.of("sessionId", sessionId))
                    .timestamp(LocalDateTime.now().toString())
                    .build();
            customerHandler.sendToCustomer(tenantId, session.getUserId(), sessionId, typingMessage);
        }
    }
}
```

---

## ğŸ§  è½¬äººå·¥æ ¸å¿ƒé€»è¾‘

### 1. è½¬äººå·¥é˜Ÿåˆ—æœåŠ¡ï¼ˆRedisï¼‰

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/service/HandoffQueueService.java`

```java
package com.ityfz.yulu.handoff.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * è½¬äººå·¥æ’é˜Ÿé˜Ÿåˆ—æœåŠ¡ï¼ˆåŸºäºRedisï¼‰
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class HandoffQueueService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    private static final String QUEUE_KEY_PREFIX = "handoff:queue:";
    private static final int QUEUE_TTL_HOURS = 1; // é˜Ÿåˆ—1å°æ—¶è¿‡æœŸ
    
    /**
     * åŠ å…¥æ’é˜Ÿé˜Ÿåˆ—
     * @return æ’é˜Ÿä½ç½®ï¼ˆä»1å¼€å§‹ï¼‰
     */
    public int addToQueue(Long tenantId, Long handoffRequestId) {
        String queueKey = QUEUE_KEY_PREFIX + tenantId;
        Long position = redisTemplate.opsForList().rightPush(queueKey, handoffRequestId.toString());
        redisTemplate.expire(queueKey, QUEUE_TTL_HOURS, TimeUnit.HOURS);
        
        int queuePosition = position != null ? position.intValue() : 0;
        log.info("[HandoffQueue] åŠ å…¥é˜Ÿåˆ—ï¼štenantId={}, handoffRequestId={}, position={}", 
                tenantId, handoffRequestId, queuePosition);
        return queuePosition;
    }
    
    /**
     * è·å–æ’é˜Ÿä½ç½®
     * @return æ’é˜Ÿä½ç½®ï¼ˆä»1å¼€å§‹ï¼‰ï¼Œ0è¡¨ç¤ºä¸åœ¨é˜Ÿåˆ—ä¸­
     */
    public int getQueuePosition(Long tenantId, Long handoffRequestId) {
        String queueKey = QUEUE_KEY_PREFIX + tenantId;
        List<Object> queue = redisTemplate.opsForList().range(queueKey, 0, -1);
        
        if (queue == null || queue.isEmpty()) {
            return 0;
        }
        
        String requestIdStr = handoffRequestId.toString();
        for (int i = 0; i < queue.size(); i++) {
            if (requestIdStr.equals(queue.get(i).toString())) {
                return i + 1; // ä½ç½®ä»1å¼€å§‹
            }
        }
        return 0;
    }
    
    /**
     * ä»é˜Ÿåˆ—ç§»é™¤
     */
    public void removeFromQueue(Long tenantId, Long handoffRequestId) {
        String queueKey = QUEUE_KEY_PREFIX + tenantId;
        Long removed = redisTemplate.opsForList().remove(queueKey, 1, handoffRequestId.toString());
        
        if (removed != null && removed > 0) {
            log.info("[HandoffQueue] ä»é˜Ÿåˆ—ç§»é™¤ï¼štenantId={}, handoffRequestId={}", tenantId, handoffRequestId);
        }
    }
    
    /**
     * è·å–é˜Ÿåˆ—é•¿åº¦
     */
    public int getQueueLength(Long tenantId) {
        String queueKey = QUEUE_KEY_PREFIX + tenantId;
        Long length = redisTemplate.opsForList().size(queueKey);
        return length != null ? length.intValue() : 0;
    }
    
    /**
     * è·å–é˜Ÿåˆ—å¤´éƒ¨å…ƒç´ ï¼ˆä¸ç§»é™¤ï¼‰
     */
    public Long peekQueue(Long tenantId) {
        String queueKey = QUEUE_KEY_PREFIX + tenantId;
        Object first = redisTemplate.opsForList().index(queueKey, 0);
        
        if (first != null) {
            try {
                return Long.parseLong(first.toString());
            } catch (NumberFormatException e) {
                log.warn("[HandoffQueue] é˜Ÿåˆ—å…ƒç´ æ ¼å¼é”™è¯¯ï¼š{}", first);
            }
        }
        return null;
    }
    
    /**
     * ä»é˜Ÿåˆ—å¤´éƒ¨å–å‡ºå…ƒç´ ï¼ˆç§»é™¤ï¼‰
     */
    public Long pollQueue(Long tenantId) {
        String queueKey = QUEUE_KEY_PREFIX + tenantId;
        Object first = redisTemplate.opsForList().leftPop(queueKey);
        
        if (first != null) {
            try {
                Long handoffRequestId = Long.parseLong(first.toString());
                log.info("[HandoffQueue] ä»é˜Ÿåˆ—å–å‡ºï¼štenantId={}, handoffRequestId={}", tenantId, handoffRequestId);
                return handoffRequestId;
            } catch (NumberFormatException e) {
                log.warn("[HandoffQueue] é˜Ÿåˆ—å…ƒç´ æ ¼å¼é”™è¯¯ï¼š{}", first);
            }
        }
        return null;
    }
}
```

### 2. æ™ºèƒ½åˆ†é…å™¨

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/service/AgentAssigner.java`

```java
package com.ityfz.yulu.handoff.service;

import com.ityfz.yulu.handoff.entity.HandoffRequest;
import com.ityfz.yulu.handoff.mapper.HandoffRequestMapper;
import com.ityfz.yulu.user.entity.AgentConfig;
import com.ityfz.yulu.user.entity.User;
import com.ityfz.yulu.user.mapper.AgentConfigMapper;
import com.ityfz.yulu.user.mapper.UserMapper;
import com.ityfz.yulu.user.service.AgentStatusService;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

/**
 * æ™ºèƒ½åˆ†é…å™¨ï¼ˆå¤šç»´åº¦è¯„åˆ†ç®—æ³•ï¼‰
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class AgentAssigner {
    
    private final AgentStatusService agentStatusService;
    private final UserMapper userMapper;
    private final AgentConfigMapper agentConfigMapper;
    private final HandoffRequestMapper handoffRequestMapper;
    
    /**
     * åˆ†é…å®¢æœ
     * @return åˆ†é…çš„å®¢æœIDï¼Œnullè¡¨ç¤ºæ²¡æœ‰å¯åˆ†é…çš„å®¢æœ
     */
    public Long assignAgent(Long tenantId, Long handoffRequestId) {
        HandoffRequest request = handoffRequestMapper.selectById(handoffRequestId);
        if (request == null) {
            log.warn("[AgentAssigner] è½¬äººå·¥è¯·æ±‚ä¸å­˜åœ¨ï¼šhandoffRequestId={}", handoffRequestId);
            return null;
        }
        
        // 1. è·å–åœ¨çº¿å®¢æœåˆ—è¡¨
        List<Long> onlineAgentIds = agentStatusService.getOnlineAgents(tenantId);
        if (onlineAgentIds.isEmpty()) {
            log.info("[AgentAssigner] æ²¡æœ‰åœ¨çº¿å®¢æœï¼štenantId={}", tenantId);
            return null;
        }
        
        // 2. æ„å»ºå€™é€‰å®¢æœåˆ—è¡¨
        List<AgentCandidate> candidates = buildCandidates(tenantId, onlineAgentIds);
        
        // 3. å¤šç»´åº¦è¯„åˆ†
        for (AgentCandidate candidate : candidates) {
            double score = calculateScore(candidate, request);
            candidate.setScore(score);
        }
        
        // 4. æ’åºå¹¶é€‰æ‹©æœ€ä¼˜å®¢æœ
        candidates.sort((a, b) -> Double.compare(b.getScore(), a.getScore()));
        
        // 5. é€‰æ‹©ç¬¬ä¸€ä¸ªå¯æ¥å…¥çš„å®¢æœ
        for (AgentCandidate candidate : candidates) {
            if (agentStatusService.canAcceptSession(tenantId, candidate.getAgentId())) {
                log.info("[AgentAssigner] åˆ†é…å®¢æœæˆåŠŸï¼šhandoffRequestId={}, agentId={}, score={}", 
                        handoffRequestId, candidate.getAgentId(), candidate.getScore());
                return candidate.getAgentId();
            }
        }
        
        log.info("[AgentAssigner] æ²¡æœ‰å¯æ¥å…¥çš„å®¢æœï¼ˆè´Ÿè½½å·²æ»¡ï¼‰ï¼štenantId={}", tenantId);
        return null;
    }
    
    /**
     * æ„å»ºå€™é€‰å®¢æœåˆ—è¡¨
     */
    private List<AgentCandidate> buildCandidates(Long tenantId, List<Long> agentIds) {
        List<AgentCandidate> candidates = new ArrayList<>();
        
        for (Long agentId : agentIds) {
            // è·å–ç”¨æˆ·ä¿¡æ¯
            User user = userMapper.selectById(agentId);
            if (user == null || !user.getTenantId().equals(tenantId)) {
                continue;
            }
            
            // è·å–å®¢æœé…ç½®
            AgentConfig config = agentConfigMapper.selectOne(
                    com.baomidou.mybatisplus.core.toolkit.Wrappers.<AgentConfig>lambdaQuery()
                            .eq(AgentConfig::getTenantId, tenantId)
                            .eq(AgentConfig::getUserId, agentId)
                            .last("LIMIT 1")
            );
            
            // è·å–åœ¨çº¿çŠ¶æ€
            Map<String, Object> status = agentStatusService.getAgentStatus(tenantId, agentId);
            String currentStatus = (String) status.getOrDefault("status", "OFFLINE");
            Integer currentSessions = (Integer) status.getOrDefault("current_sessions", 0);3
            Integer maxSessions = (Integer) status.getOrDefault("max_sessions", 5);
            
            // æ„å»ºå€™é€‰å¯¹è±¡
            AgentCandidate candidate = new AgentCandidate();
            candidate.setAgentId(agentId);
            candidate.setStatus(currentStatus);
            candidate.setCurrentSessions(currentSessions);
            candidate.setMaxSessions(maxSessions);
            candidate.setSkillTags(config != null && config.getSkillTags() != null 
                    ? config.getSkillTags() : "");
            candidate.setAutoAccept(config != null && config.getAutoAccept() != null 
                    && config.getAutoAccept() == 1);
            candidate.setSeniorAgent("ADMIN".equals(user.getRole())); // ç®¡ç†å‘˜è§†ä¸ºé«˜çº§å®¢æœ
            
            candidates.add(candidate);
        }
        
        return candidates;
    }
    
    /**
     * è®¡ç®—è¯„åˆ†
     */
    private double calculateScore(AgentCandidate candidate, HandoffRequest request) {
        double score = 0.0;
        
        // 1. åœ¨çº¿çŠ¶æ€æƒé‡ï¼š40%
        if ("ONLINE".equals(candidate.getStatus())) {
            score += 40;
        } else if ("AWAY".equals(candidate.getStatus())) {
            score += 20;
        }
        
        // 2. è´Ÿè½½æƒé‡ï¼š30%ï¼ˆè´Ÿè½½è¶Šä½åˆ†æ•°è¶Šé«˜ï¼‰
        if (candidate.getMaxSessions() > 0) {
            double loadRatio = candidate.getCurrentSessions() / (double) candidate.getMaxSessions();
            score += 30 * (1 - loadRatio);
        }
        
        // 3. æŠ€èƒ½åŒ¹é…æƒé‡ï¼š20%ï¼ˆå¦‚æœæœ‰æŠ€èƒ½æ ‡ç­¾åŒ¹é…ï¼ŒåŠ åˆ†ï¼‰
        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…å¯ä»¥æ ¹æ®è½¬äººå·¥åŸå› åŒ¹é…æŠ€èƒ½æ ‡ç­¾
        if (candidate.getSkillTags() != null && !candidate.getSkillTags().isEmpty()) {
            score += 20; // æœ‰æŠ€èƒ½æ ‡ç­¾å°±åŠ åˆ†
        }
        
        // 4. å†å²æœåŠ¡è´¨é‡æƒé‡ï¼š10%ï¼ˆè¿™é‡Œç®€åŒ–ï¼Œå®é™…å¯ä»¥ä»å†å²æ•°æ®è®¡ç®—ï¼‰
        score += 10; // é»˜è®¤ç»™10åˆ†
        
        // 5. ä¼˜å…ˆçº§åŠ æˆï¼ˆURGENTä¼˜å…ˆåˆ†é…ç»™é«˜çº§å®¢æœï¼‰
        if ("URGENT".equals(request.getPriority()) && candidate.isSeniorAgent()) {
            score += 10;
        }
        
        // 6. è‡ªåŠ¨æ¥å…¥åŠ æˆï¼ˆå¦‚æœé…ç½®äº†è‡ªåŠ¨æ¥å…¥ï¼Œä¼˜å…ˆåˆ†é…ï¼‰
        if (candidate.isAutoAccept()) {
            score += 5;
        }
        
        return score;
    }
    
    /**
     * å€™é€‰å®¢æœå†…éƒ¨ç±»
     */
    @Data
    private static class AgentCandidate {
        private Long agentId;
        private String status;
        private Integer currentSessions;
        private Integer maxSessions;
        private String skillTags;
        private boolean autoAccept;
        private boolean seniorAgent;
        private double score;
    }
}
```

### 3. è½¬äººå·¥æœåŠ¡ï¼ˆæ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼‰

**æ–‡ä»¶è·¯å¾„**ï¼š`src/main/java/com/ityfz/yulu/handoff/service/HandoffService.java`

```java
package com.ityfz.yulu.handoff.service;

import com.ityfz.yulu.chat.entity.ChatSession;
import com.ityfz.yulu.chat.mapper.ChatSessionMapper;
import com.ityfz.yulu.common.enums.ErrorCodes;
import com.ityfz.yulu.common.exception.BizException;
import com.ityfz.yulu.handoff.dto.*;
import com.ityfz.yulu.handoff.entity.HandoffRequest;
import com.ityfz.yulu.handoff.enums.HandoffEventType;
import com.ityfz.yulu.handoff.enums.HandoffStatus;
import com.ityfz.yulu.handoff.enums.OperatorType;
import com.ityfz.yulu.handoff.mapper.HandoffEventMapper;
import com.ityfz.yulu.handoff.mapper.HandoffRequestMapper;
import com.ityfz.yulu.handoff.websocket.AgentWebSocketHandler;
import com.ityfz.yulu.handoff.websocket.CustomerWebSocketHandler;
import com.ityfz.yulu.handoff.websocket.WebSocketMessage;
import com.ityfz.yulu.ticket.entity.Ticket;
import com.ityfz.yulu.ticket.enums.TicketPriority;
import com.ityfz.yulu.ticket.enums.TicketStatus;
import com.ityfz.yulu.ticket.mapper.TicketMapper;
import com.ityfz.yulu.ticket.service.TicketService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * è½¬äººå·¥æœåŠ¡ï¼ˆæ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼‰
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class HandoffService {
    
    private final HandoffRequestMapper handoffRequestMapper;
    private final HandoffEventMapper handoffEventMapper;
    private final ChatSessionMapper chatSessionMapper;
    private final TicketMapper ticketMapper;
    private final TicketService ticketService;
    private final HandoffQueueService queueService;
    private final AgentAssigner agentAssigner;
    private final AgentStatusService agentStatusService;
    private final CustomerWebSocketHandler customerHandler;
    private final AgentWebSocketHandler agentHandler;
    
    /**
     * è½¬äººå·¥ç”³è¯·
     */
    @Transactional
    public HandoffTransferResponse transferToAgent(Long tenantId, Long userId, Long sessionId, String reason) {
        // 1. éªŒè¯ä¼šè¯
        ChatSession session = chatSessionMapper.selectById(sessionId);
        if (session == null || !session.getTenantId().equals(tenantId) || !session.getUserId().equals(userId)) {
            throw new BizException(ErrorCodes.UNAUTHORIZED, "ä¼šè¯ä¸å­˜åœ¨æˆ–æ— æƒé™");
        }
        
        // 2. æ£€æŸ¥æ˜¯å¦å·²æœ‰æœªå®Œæˆçš„è½¬äººå·¥è¯·æ±‚
        HandoffRequest existing = handoffRequestMapper.selectUncompletedBySessionId(sessionId);
        if (existing != null && !HandoffStatus.isCompleted(existing.getStatus())) {
            throw new BizException(ErrorCodes.VALIDATION_ERROR, "å·²æœ‰è½¬äººå·¥è¯·æ±‚ï¼Œè¯·å‹¿é‡å¤ç”³è¯·");
        }
        
        // 3. æ£€æŸ¥/åˆ›å»ºå·¥å•
        Ticket ticket = findOrCreateTicket(tenantId, userId, sessionId, reason);
        
        // 4. åˆ›å»ºè½¬äººå·¥è¯·æ±‚
        HandoffRequest request = new HandoffRequest();
        request.setTenantId(tenantId);
        request.setSessionId(sessionId);
        request.setUserId(userId);
        request.setTicketId(ticket.getId());
        request.setStatus(HandoffStatus.PENDING.getCode());
        request.setReason(reason);
        request.setPriority(calculatePriority(session)); // åŸºäºä¼šè¯è®¡ç®—ä¼˜å…ˆçº§
        handoffRequestMapper.insert(request);
        
        // 5. æ›´æ–°ä¼šè¯çŠ¶æ€
        session.setChatMode("AGENT");
        session.setHandoffRequestId(request.getId());
        chatSessionMapper.updateById(session);
        
        // 6. è¿›å…¥æ’é˜Ÿé˜Ÿåˆ—
        int queuePosition = queueService.addToQueue(tenantId, request.getId());
        request.setQueuePosition(queuePosition);
        handoffRequestMapper.updateById(request);
        
        // 7. è®°å½•äº‹ä»¶
        recordEvent(request.getId(), HandoffEventType.CREATED, userId, OperatorType.USER, null);
        
        // 8. å¼‚æ­¥è§¦å‘æ™ºèƒ½åˆ†é…
        asyncAssignAgent(tenantId, request.getId());
        
        // 9. è¿”å›ç»“æœ
        int estimatedWaitTime = calculateEstimatedWaitTime(tenantId, queuePosition);
        return HandoffTransferResponse.builder()
                .handoffRequestId(request.getId())
                .ticketId(ticket.getId())
                .queuePosition(queuePosition)
                .estimatedWaitTime(estimatedWaitTime)
                .build();
    }
    
    /**
     * æŸ¥æ‰¾æˆ–åˆ›å»ºå·¥å•
     */
    private Ticket findOrCreateTicket(Long tenantId, Long userId, Long sessionId, String reason) {
        // å…ˆæŸ¥æ‰¾æ˜¯å¦å·²æœ‰å…³è”çš„å·¥å•
        Ticket existingTicket = ticketMapper.selectOne(
                com.baomidou.mybatisplus.core.toolkit.Wrappers.<Ticket>lambdaQuery()
                        .eq(Ticket::getTenantId, tenantId)
                        .eq(Ticket::getSessionId, sessionId)
                        .in(Ticket::getStatus, 
                                TicketStatus.PENDING.getCode(), 
                                TicketStatus.PROCESSING.getCode())
                        .last("LIMIT 1")
        );
        
        if (existingTicket != null) {
            return existingTicket;
        }
        
        // åˆ›å»ºæ–°å·¥å•
        String title = "è½¬äººå·¥-ä¼šè¯#" + sessionId;
        String description = reason != null ? reason : "å®¢æˆ·ç”³è¯·è½¬äººå·¥æœåŠ¡";
        
        Ticket ticket = ticketService.createTicketOnNegative(
                tenantId, userId, sessionId, description, TicketPriority.MEDIUM.getCode());
        
        log.info("[HandoffService] åˆ›å»ºå·¥å•ï¼šticketId={}, sessionId={}", ticket.getId(), sessionId);
        return ticket;
    }
    
    /**
     * è®¡ç®—ä¼˜å…ˆçº§ï¼ˆåŸºäºä¼šè¯ä¿¡æ¯ï¼‰
     */
    private String calculatePriority(ChatSession session) {
        // ç®€åŒ–å¤„ç†ï¼Œå¯ä»¥æ ¹æ®ä¼šè¯æ—¶é•¿ã€æ¶ˆæ¯æ•°é‡ç­‰è®¡ç®—
        return TicketPriority.MEDIUM.getCode();
    }
    
    /**
     * è®¡ç®—é¢„è®¡ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰
     */
    private int calculateEstimatedWaitTime(Long tenantId, int queuePosition) {
        // ç®€åŒ–å¤„ç†ï¼šå‡è®¾æ¯ä¸ªè¯·æ±‚å¹³å‡å¤„ç†æ—¶é—´30ç§’
        int avgProcessTime = 30;
        return queuePosition * avgProcessTime;
    }
    
    /**
     * å¼‚æ­¥åˆ†é…å®¢æœ
     */
    @Async
    public void asyncAssignAgent(Long tenantId, Long handoffRequestId) {
        try {
            Thread.sleep(1000); // å»¶è¿Ÿ1ç§’ï¼Œç¡®ä¿è¯·æ±‚å·²ä¿å­˜
            
            Long agentId = agentAssigner.assignAgent(tenantId, handoffRequestId);
            if (agentId != null) {
                // åˆ†é…æˆåŠŸï¼Œæ›´æ–°è¯·æ±‚çŠ¶æ€
                HandoffRequest request = handoffRequestMapper.selectById(handoffRequestId);
                request.setAgentId(agentId);
                request.setStatus(HandoffStatus.ASSIGNED.getCode());
                request.setAssignedAt(LocalDateTime.now());
                handoffRequestMapper.updateById(request);
                
                // è®°å½•äº‹ä»¶
                recordEvent(handoffRequestId, HandoffEventType.ASSIGNED, agentId, OperatorType.SYSTEM, null);
                
                // WebSocketæ¨é€é€šçŸ¥ç»™å®¢æœ
                sendHandoffRequestNotification(tenantId, agentId, request);
            }
        } catch (Exception e) {
            log.error("[HandoffService] å¼‚æ­¥åˆ†é…å®¢æœå¤±è´¥ï¼šhandoffRequestId={}", handoffRequestId, e);
        }
    }
    
    /**
     * å‘é€è½¬äººå·¥è¯·æ±‚é€šçŸ¥ç»™å®¢æœ
     */
    private void sendHandoffRequestNotification(Long tenantId, Long agentId, HandoffRequest request) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("handoffRequestId", request.getId());
        payload.put("sessionId", request.getSessionId());
        payload.put("userId", request.getUserId());
        payload.put("ticketId", request.getTicketId());
        payload.put("priority", request.getPriority());
        payload.put("reason", request.getReason());
        payload.put("queuePosition", request.getQueuePosition());
        
        WebSocketMessage message = WebSocketMessage.builder()
                .type("HANDOFF_REQUEST")
                .payload(payload)
                .timestamp(LocalDateTime.now().toString())
                .build();
        
        agentHandler.sendToAgent(tenantId, agentId, message);
        log.info("[HandoffService] è½¬äººå·¥è¯·æ±‚é€šçŸ¥å·²å‘é€ï¼šagentId={}, handoffRequestId={}", agentId, request.getId());
    }
    
    /**
     * å®¢æœæ¥å—è½¬äººå·¥è¯·æ±‚
     */
    @Transactional
    public HandoffAcceptResponse acceptHandoff(Long tenantId, Long agentId, Long handoffRequestId) {
        // 1. éªŒè¯è¯·æ±‚
        HandoffRequest request = handoffRequestMapper.selectById(handoffRequestId);
        if (request == null || !request.getTenantId().equals(tenantId)) {
            throw new BizException(ErrorCodes.UNAUTHORIZED, "è½¬äººå·¥è¯·æ±‚ä¸å­˜åœ¨");
        }
        
        if (!agentId.equals(request.getAgentId())) {
            throw new BizException(ErrorCodes.FORBIDDEN, "æ— æƒé™æ¥å—æ­¤è½¬äººå·¥è¯·æ±‚");
        }
        
        if (!HandoffStatus.ASSIGNED.getCode().equals(request.getStatus())) {
            throw new BizException(ErrorCodes.VALIDATION_ERROR, "è½¬äººå·¥è¯·æ±‚çŠ¶æ€ä¸æ­£ç¡®");
        }
        
        // 2. æ£€æŸ¥æ˜¯å¦å¯æ¥å…¥
        if (!agentStatusService.canAcceptSession(tenantId, agentId)) {
            throw new BizException(ErrorCodes.VALIDATION_ERROR, "å½“å‰è´Ÿè½½å·²æ»¡ï¼Œæ— æ³•æ¥å…¥");
        }
        
        // 3. æ›´æ–°è¯·æ±‚çŠ¶æ€
        request.setStatus(HandoffStatus.ACCEPTED.getCode());
        request.setAcceptedAt(LocalDateTime.now());
        handoffRequestMapper.updateById(request);
        
        // 4. æ›´æ–°ä¼šè¯
        ChatSession session = chatSessionMapper.selectById(request.getSessionId());
        session.setAgentId(agentId);
        session.setChatMode("AGENT");
        chatSessionMapper.updateById(session);
        
        // 5. æ›´æ–°å·¥å•çŠ¶æ€
        Ticket ticket = ticketMapper.selectById(request.getTicketId());
        ticket.setStatus(TicketStatus.PROCESSING.getCode());
        ticket.setAssignee(agentId);
        ticketMapper.updateById(ticket);
        
        // 6. å¢åŠ å®¢æœä¼šè¯æ•°
        agentStatusService.incrementSessionCount(tenantId, agentId);
        
        // 7. ä»æ’é˜Ÿé˜Ÿåˆ—ç§»é™¤
        queueService.removeFromQueue(tenantId, handoffRequestId);
        
        // 8. è®°å½•äº‹ä»¶
        recordEvent(handoffRequestId, HandoffEventType.ACCEPTED, agentId, OperatorType.AGENT, null);
        
        // 9. WebSocketé€šçŸ¥å®¢æˆ·
        sendHandoffAcceptedNotification(tenantId, request.getUserId(), request.getSessionId(), agentId);
        
        return HandoffAcceptResponse.builder()
                .handoffRequestId(handoffRequestId)
                .sessionId(request.getSessionId())
                .userId(request.getUserId())
                .ticketId(request.getTicketId())
                .build();
    }
    
    /**
     * å‘é€å®¢æœå·²æ¥å—é€šçŸ¥ç»™å®¢æˆ·
     */
    private void sendHandoffAcceptedNotification(Long tenantId, Long userId, Long sessionId, Long agentId) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("sessionId", sessionId);
        payload.put("agentId", agentId);
        
        WebSocketMessage message = WebSocketMessage.builder()
                .type("HANDOFF_ACCEPTED")
                .payload(payload)
                .timestamp(LocalDateTime.now().toString())
                .build();
        
        customerHandler.sendToCustomer(tenantId, userId, sessionId, message);
        log.info("[HandoffService] å®¢æœå·²æ¥å—é€šçŸ¥å·²å‘é€ï¼šuserId={}, sessionId={}, agentId={}", userId, sessionId, agentId);
    }
    
    /**
     * è®°å½•äº‹ä»¶
     */
    private void recordEvent(Long handoffRequestId, HandoffEventType eventType, Long operatorId, 
                            OperatorType operatorType, Map<String, Object> eventData) {
        HandoffRequest request = handoffRequestMapper.selectById(handoffRequestId);
        if (request == null) {
            return;
        }
        
        com.ityfz.yulu.handoff.entity.HandoffEvent event = new com.ityfz.yulu.handoff.entity.HandoffEvent();
        event.setTenantId(request.getTenantId());
        event.setHandoffRequestId(handoffRequestId);
        event.setEventType(eventType.getCode());
        event.setOperatorId(operatorId);
        event.setOperatorType(operatorType.getCode());
        
        if (eventData != null) {
            event.setEventData(com.alibaba.fastjson.JSON.toJSONString(eventData));
        }
        
        handoffEventMapper.insert(event);
    }
    
    /**
     * æŸ¥è¯¢è½¬äººå·¥çŠ¶æ€
     */
    public HandoffStatusResponse getHandoffStatus(Long tenantId, Long userId, Long handoffRequestId) {
        HandoffRequest request = handoffRequestMapper.selectById(handoffRequestId);
        if (request == null || !request.getTenantId().equals(tenantId) || !request.getUserId().equals(userId)) {
            throw new BizException(ErrorCodes.UNAUTHORIZED, "è½¬äººå·¥è¯·æ±‚ä¸å­˜åœ¨æˆ–æ— æƒé™");
        }
        
        // æ›´æ–°æ’é˜Ÿä½ç½®
        int queuePosition = queueService.getQueuePosition(tenantId, handoffRequestId);
        if (queuePosition > 0 && request.getQueuePosition() != queuePosition) {
            request.setQueuePosition(queuePosition);
            handoffRequestMapper.updateById(request);
        }
        
        String agentName = null;
        if (request.getAgentId() != null) {
            // è·å–å®¢æœåç§°ï¼ˆè¿™é‡Œç®€åŒ–ï¼Œå®é™…å¯ä»¥ä»Userè¡¨æŸ¥è¯¢ï¼‰
            agentName = "å®¢æœ#" + request.getAgentId();
        }
        
        int estimatedWaitTime = calculateEstimatedWaitTime(tenantId, queuePosition);
        
        return HandoffStatusResponse.builder()
                .handoffRequestId(handoffRequestId)
                .status(request.getStatus())
                .queuePosition(queuePosition > 0 ? queuePosition : null)
                .estimatedWaitTime(estimatedWaitTime)
                .assignedAgentId(request.getAgentId())
                .assignedAgentName(agentName)
                .build();
    }
    
    /**
     * è·å–å®¢æœå¾…å¤„ç†çš„è½¬äººå·¥è¯·æ±‚åˆ—è¡¨
     */
    public List<HandoffRequestItemDTO> getPendingHandoffRequests(Long tenantId, Long agentId) {
        List<HandoffRequest> requests = handoffRequestMapper.selectPendingByAgentId(tenantId, agentId);
        
        return requests.stream().map(request -> {
            // è¿™é‡Œç®€åŒ–ï¼Œå®é™…å¯ä»¥ä»Userè¡¨æŸ¥è¯¢å®¢æˆ·åç§°
            String userName = "å®¢æˆ·#" + request.getUserId();
            
            // è·å–å·¥å•æ ‡é¢˜
            String ticketTitle = "è½¬äººå·¥-ä¼šè¯#" + request.getSessionId();
            if (request.getTicketId() != null) {
                Ticket ticket = ticketMapper.selectById(request.getTicketId());
                if (ticket != null) {
                    ticketTitle = ticket.getTitle();
                }
            }
            
            return HandoffRequestItemDTO.builder()
                    .handoffRequestId(request.getId())
                    .sessionId(request.getSessionId())
                    .userId(request.getUserId())
                    .userName(userName)
                    .ticketId(request.getTicketId())
                    .ticketTitle(ticketTitle)
                    .priority(request.getPriority())
                    .reason(request.getReason())
                    .queuePosition(request.getQueuePosition())
                    .createdAt(request.getCreateTime())
                    .build();
        }).collect(Collectors.toList());
    }
}
```

---

## ğŸ“ å®ç°æ­¥éª¤

### æ­¥éª¤1ï¼šæ‰§è¡Œæ•°æ®åº“SQLï¼ˆ5åˆ†é’Ÿï¼‰

1. åœ¨MySQLä¸­æ‰§è¡Œä¸Šè¿°SQLè„šæœ¬ï¼Œåˆ›å»ºè¡¨ç»“æ„
2. éªŒè¯è¡¨æ˜¯å¦åˆ›å»ºæˆåŠŸ

### æ­¥éª¤2ï¼šåˆ›å»ºå®ä½“ç±»å’ŒMapperï¼ˆ10åˆ†é’Ÿï¼‰

1. åˆ›å»ºåŒ…ç»“æ„ï¼š
   - `src/main/java/com/ityfz/yulu/handoff/entity/`
   - `src/main/java/com/ityfz/yulu/handoff/mapper/`
   - `src/main/java/com/ityfz/yulu/handoff/dto/`
   - `src/main/java/com/ityfz/yulu/handoff/enums/`

2. æŒ‰ç…§ä¸Šè¿°ä»£ç åˆ›å»ºæ‰€æœ‰å®ä½“ç±»ã€Mapperã€DTOã€æšä¸¾ç±»

3. éªŒè¯ç¼–è¯‘é€šè¿‡

### æ­¥éª¤3ï¼šæ·»åŠ WebSocketä¾èµ–ï¼ˆ2åˆ†é’Ÿï¼‰

1. åœ¨`pom.xml`ä¸­æ·»åŠ WebSocketä¾èµ–
2. æ‰§è¡Œ`mvn clean install`éªŒè¯ä¾èµ–ä¸‹è½½æˆåŠŸ

### æ­¥éª¤4ï¼šåˆ›å»ºWebSocketåŸºç¡€è®¾æ–½ï¼ˆ20åˆ†é’Ÿï¼‰

1. åˆ›å»ºåŒ…ç»“æ„ï¼š
   - `src/main/java/com/ityfz/yulu/handoff/websocket/`

2. æŒ‰ç…§ä¸Šè¿°ä»£ç åˆ›å»ºï¼š
   - `WebSocketConfig.java`
   - `WebSocketHandshakeInterceptor.java`
   - `CustomerWebSocketHandler.java`
   - `AgentWebSocketHandler.java`
   - `WebSocketMessage.java`
   - `WebSocketMessageService.java`

3. éªŒè¯ç¼–è¯‘é€šè¿‡

### æ­¥éª¤5ï¼šåˆ›å»ºè½¬äººå·¥æ ¸å¿ƒé€»è¾‘ï¼ˆ30åˆ†é’Ÿï¼‰

1. åˆ›å»ºåŒ…ç»“æ„ï¼š
   - `src/main/java/com/ityfz/yulu/handoff/service/`

2. æŒ‰ç…§ä¸Šè¿°ä»£ç åˆ›å»ºï¼š
   - `HandoffQueueService.java`
   - `AgentAssigner.java`
   - `HandoffService.java`

3. æ³¨æ„ï¼š`HandoffService`ä¸­çš„`@Async`éœ€è¦å¯ç”¨å¼‚æ­¥æ”¯æŒï¼Œåœ¨å¯åŠ¨ç±»æ·»åŠ `@EnableAsync`

4. éªŒè¯ç¼–è¯‘é€šè¿‡

### æ­¥éª¤6ï¼šæµ‹è¯•åŸºç¡€åŠŸèƒ½ï¼ˆ30åˆ†é’Ÿï¼‰

1. å¯åŠ¨åº”ç”¨ï¼ŒéªŒè¯æ— å¯åŠ¨é”™è¯¯
2. æµ‹è¯•WebSocketè¿æ¥ï¼ˆå¯ä»¥ä½¿ç”¨Postmanæˆ–æµè§ˆå™¨æ§åˆ¶å°ï¼‰
3. æµ‹è¯•è½¬äººå·¥ç”³è¯·æ¥å£ï¼ˆéœ€è¦å…ˆåˆ›å»ºControllerï¼Œä¸‹ä¸€éƒ¨åˆ†ä¼šç»™å‡ºï¼‰

---

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **JWTå·¥å…·ç±»**ï¼šç¡®ä¿`JwtUtil.parseToken()`æ–¹æ³•å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨éœ€è¦å®ç°
2. **å¼‚æ­¥æ”¯æŒ**ï¼šåœ¨å¯åŠ¨ç±»æ·»åŠ `@EnableAsync`æ³¨è§£
3. **FastJSONä¾èµ–**ï¼šå¦‚æœä½¿ç”¨FastJSONï¼Œç¡®ä¿pom.xmlä¸­æœ‰ä¾èµ–
4. **ç¼–è¯‘é”™è¯¯**ï¼šå¦‚æœé‡åˆ°ç¼–è¯‘é”™è¯¯ï¼Œæ£€æŸ¥å¯¼å…¥çš„åŒ…æ˜¯å¦æ­£ç¡®

---

## ğŸ“Œ ä¸‹ä¸€æ­¥

å®Œæˆä»¥ä¸Šæ­¥éª¤åï¼Œä¸‹ä¸€éƒ¨åˆ†å°†æä¾›ï¼š
- Controllerå±‚ï¼ˆAPIæ¥å£ï¼‰
- å‰ç«¯WebSocketå®¢æˆ·ç«¯å°è£…
- å‰ç«¯è½¬äººå·¥ç•Œé¢
- å®Œæ•´çš„æµ‹è¯•ç”¨ä¾‹

è¯·å…ˆå®Œæˆä»¥ä¸Šä»£ç çš„å®ç°ï¼Œå¦‚æœ‰é—®é¢˜éšæ—¶è¯¢é—®ï¼

