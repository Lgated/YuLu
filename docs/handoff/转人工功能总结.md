# 转人工功能总结（YuLu）

本文档基于当前代码实现（`src/main/java/com/ityfz/yulu/handoff` 及其协作模块）整理，用于：

- 复盘“转人工”功能是如何实现的
- 帮助快速理解各模块之间的关系与数据流
- 面试/答辩时作为讲解提纲与问答参考

---

## 1. 功能目标与边界

### 1.1 目标

当用户在 AI 对话过程中选择“转人工”时，系统提供：

- 用户端发起转人工申请、查看排队/接入状态
- 系统自动分配在线客服，并将请求推送给客服端处理
- 客服端接受后建立人工会话，双方通过 WebSocket 实时收发消息
- 会话结束（客服完成 / 用户结束）后，状态收敛、资源释放，并回到 AI 模式
- 无客服在线时自动兜底转工单，保证用户有闭环反馈

### 1.2 非目标（当前实现未强依赖）

- 精细到 DB 枚举层面的“用户结束/客服结束”差异化统计（当前用事件 data 扩展字段区分）
- 强可靠消息投递（当前以 DB 状态为准 + 前端轮询/重连恢复为补偿）

---

## 2. 整体架构

转人工子系统是典型的 **HTTP 状态流转 + WebSocket 实时推送** 的组合架构。

- **HTTP**：用于“状态变更类操作”
  - 申请转人工、接受、拒绝、取消、完成、用户结束
- **WebSocket**：用于“实时通知/消息收发”
  - 客服请求推送、客服接入通知、对话消息、结束通知、排队更新
- **DB（handoff_request + handoff_event）**：作为权威状态源
  - WebSocket 若丢消息，可通过状态查询恢复

---

## 3. 代码结构与职责（handoff 目录）

### 3.1 Controller（HTTP 接口层）

- `CustomerHandoffController`（`/api/customer/handoff`）
  - `POST /transfer`：用户申请转人工
  - `GET /status/{handoffRequestId}`：查询转人工状态
  - `POST /cancel/{handoffRequestId}`：用户取消（客服接入前）
  - `POST /end-by-user`：用户结束人工对话（已接入/进行中）

- `AgentHandoffController`（`/api/agent/handoff`）
  - `GET /pending`：客服获取待处理请求列表
  - `POST /accept`：客服接受转人工请求
  - `POST /reject`：客服拒绝
  - `POST /complete/{handoffRequestId}`：客服完成会话

Controller 的特点：

- 依赖 `SecurityUtil.currentTenantId()`、`SecurityUtil.currentUserId()` 取租户与主体 ID
- 通过 `@RequireRole` 区分 USER / AGENT 权限

### 3.2 Service（业务编排层）

- `HandoffService`：核心编排中心
  - `transferToAgent()`：用户申请转人工 + 排队 + 触发分配
  - `acceptHandoff()`：客服接受并接入
  - `cancel()`：用户取消
  - `decline()`：客服拒绝并重新入队
  - `complete()`：客服完成
  - `endByUser()`：用户结束
  - `recordEvent()`：事件审计
  - 负责调用 Ticket/Queue/AgentStatus 等协作服务

- `AgentAssigner`：客服分配策略（将分配策略从主业务解耦）

- `HandoffQueueService`：排队队列逻辑

### 3.3 WebSocket（实时通道层）

- `AgentWebSocketHandler`：向客服端推送
- `CustomerWebSocketHandler`：向用户端推送
- `WebSocketHandshakeInterceptor`：握手阶段处理身份/上下文

### 3.4 Entity/Mapper（数据层）

- `HandoffRequest`：转人工主记录（会话、用户、客服、状态、ticket 等）
- `HandoffEvent`：事件流水（审计/追踪/扩展字段）
- `HandoffRequestMapper` / `HandoffEventMapper`

### 3.5 枚举（状态机/事件类型）

- `HandoffStatus`：
  - `PENDING`（排队中）
  - `ASSIGNED`（已分配给某客服待接受）
  - `ACCEPTED`（客服已接受接入）
  - `IN_PROGRESS`（进行中，当前实现对该态兼容）
  - `COMPLETED`（已完成/已结束）
  - `CANCELLED`（已取消）
  - `FALLBACK_TICKET`（无客服在线兜底工单）

- `HandoffEventType`：`CREATED/ASSIGNED/ACCEPTED/REJECTED/COMPLETED/CANCELLED/FALLBACK_TICKET`
- `OperatorType`：`USER/AGENT/SYSTEM`

---

## 4. 核心数据模型（设计思路）

### 4.1 HandoffRequest：权威状态

`handoff_request`（对应 `HandoffRequest`）是转人工状态机的权威载体。它的关键字段组合，使系统能够：

- 做强权限校验（tenantId + userId/agentId）
- 做状态机收敛（最终进入 COMPLETED/CANCELLED/FALLBACK_TICKET）
- 关联 ChatSession 与 Ticket，形成完整闭环

### 4.2 HandoffEvent：审计与扩展

你通过 `recordEvent()` 将关键节点写入 `handoff_event`，包括：

- `eventType`：发生了什么
- `operatorType/operatorId`：谁触发
- `eventData`：JSON 扩展

这让你在不扩展 DB 枚举的情况下，也能记录额外语义（例如结束方 `endedBy=USER/AGENT`）。

---

## 5. 端到端流程（按用户/客服真实操作顺序）

### 5.1 用户申请转人工（C 端）

入口：`CustomerHandoffController.transferToAgent()` -> `HandoffService.transferToAgent()`

主要步骤：

1. 校验 ChatSession 存在且属于当前租户/用户
2. 防重复：检查 sessionId 是否已有未完成 handoff
3. 检查在线客服：
   - 若无在线客服，走 `handleFallbackToTicket()`：
     - 创建工单
     - 创建 handoff_request（`FALLBACK_TICKET`）并立即关闭
     - 插入 SYSTEM 消息给用户，返回 `fallback=true`
4. 创建或复用 Ticket（`findOrCreateTicket()`）
5. 创建 HandoffRequest（初始 `PENDING`）
6. 更新 ChatSession：`chatMode=AGENT` + 绑定 `handoffRequestId`
7. 进入排队：`handoffQueueService.addToQueue()` 返回 queuePosition
8. 记录事件：`CREATED`（OperatorType.USER）
9. 异步分配：`asyncAssignAgent()`
10. 返回给前端：handoffRequestId/ticketId/排队信息

### 5.2 系统分配客服（异步）

入口：`asyncAssignAgent()`

1. `AgentAssigner.assignAgent()` 选择客服
2. 更新 HandoffRequest：`ASSIGNED` + `agentId` + `assignedAt`
3. 写事件：`ASSIGNED`（OperatorType.SYSTEM）
4. WebSocket 推送给客服端：`HANDOFF_REQUEST`

`HANDOFF_REQUEST` payload 主要包含：

- `handoffRequestId` / `sessionId` / `userId` / `ticketId`
- `priority` / `reason` / `queuePosition`
- `userName`（当前简化为 `客户#userId`，便于前端展示）

### 5.3 客服接受（B 端）

入口：`AgentHandoffController.acceptHandoff()` -> `HandoffService.acceptHandoff()`

关键点：

1. 校验请求存在/租户一致
2. 权限：必须是被分配的 `agentId`
3. 状态：必须是 `ASSIGNED`
4. 负载：`agentStatusService.canAcceptSession()`
5. 更新状态为 `ACCEPTED` + `acceptedAt`
6. 更新 ChatSession：设置 `agentId` 且 `chatMode=AGENT`
7. 工单进入 `PROCESSING` 并设置 assignee
8. 客服会话数 +1
9. 从队列移除
10. 写事件：`ACCEPTED`（OperatorType.AGENT）
11. WS 通知用户：`HANDOFF_ACCEPTED`（携带客服名称/会话信息）

### 5.4 人工聊天消息（双向）

- 用户端处于 `ACCEPTED/IN_PROGRESS` 时，发送走 WebSocket `TEXT`
- 客服端收到 `TEXT` 后，根据 `sessionId` 分发到对应会话窗口

### 5.5 结束与收敛

#### 5.5.1 用户取消（接入前）

入口：`HandoffService.cancel()`

- 仅允许 `PENDING/ASSIGNED`
- 更新 `CANCELLED` + `closedAt`
- 队列移除、写事件
- 若已分配客服则 WS 通知客服 `HANDOFF_CANCELLED`

#### 5.5.2 客服完成（接入后）

入口：`HandoffService.complete()`

- 仅允许 `ACCEPTED/IN_PROGRESS`
- 状态更新 `COMPLETED` + `completedAt`
- ChatSession 切回 `AI`
- Ticket：`PROCESSING -> DONE`
- 客服会话数 -1
- 事件：`COMPLETED`（OperatorType.AGENT）
- WS 通知用户：`HANDOFF_COMPLETED`（payload 带 `endedBy=AGENT`）

#### 5.5.3 用户结束（接入后）

入口：`HandoffService.endByUser()`

- 仅允许 `ACCEPTED/IN_PROGRESS`
- 同样收敛到 `COMPLETED`（保持状态机兼容、避免枚举膨胀）
- 事件：`COMPLETED`（OperatorType.USER） + `eventData.endedBy=USER`
- WS 通知：
  - 用户端 `HANDOFF_COMPLETED`（endedBy=USER）
  - 若绑定客服，也通知客服端 `HANDOFF_COMPLETED`（endedBy=USER）

---

## 6. 关键设计点（为什么这么实现）

### 6.1 状态机“少而稳”，语义扩展放事件

- 结束态统一收敛为 `COMPLETED`
- “结束方是谁”用事件 `eventData.endedBy` 与 WS payload `endedBy` 表达

优点：

- 不需要频繁改 DB 枚举与前后端分支
- 审计维度更灵活，可扩展更多字段

### 6.2 DB 为准，WS 加速体验

- 任何关键状态都落库
- WS 消息用于实时体验
- 用户端提供 `getStatus` 作为补偿（WS 丢消息也能恢复）

### 6.3 多租户与权限校验贯穿全链路

- Controller 层区分角色（USER/AGENT）
- Service 层再次校验 tenantId/userId/agentId
- 避免越权操作他人的会话或请求

### 6.4 无客服在线兜底到工单

`handleFallbackToTicket()` 让业务永远有结果：

- 用户立刻收到“已创建工单”的反馈
- 系统可异步处理工单，减少用户等待焦虑

---

## 7. 常见异常与边界（你当前实现如何处理）

- 重复申请：已存在未完成 request -> 直接拒绝
- 非本人操作：userId/agentId 不匹配 -> `FORBIDDEN`
- 状态不允许：比如已完成还取消/结束 -> `VALIDATION_ERROR`
- 客服负载满：accept 时校验失败 -> 返回错误
- 无客服在线：直接 fallback 到工单闭环

---

## 8. 扩展点与可优化方向（可作为“后续规划”）

- 幂等性：对 accept/complete/endByUser 做“重复请求返回成功”语义（目前是状态不符就报错）
- 并发控制：对状态更新使用条件更新/乐观锁，防止极端情况下重复 accept
- 客服端历史消息：workbench 进入会话后拉取 ChatMessage 历史（当前多为实时追加）
- 可靠性增强：WS 消息 ack 或补偿拉取机制（目前已有 status 查询作为补偿）

---

## 9. 面试官高频问题与参考回答

### Q1：为什么 HTTP + WebSocket 混合？

**答：**

- HTTP 用于状态变更（鉴权、落库、可重试）
- WebSocket 用于实时推送/聊天消息（即时体验）
- DB 是权威状态源，WS 是加速体验；同时保留状态查询作为补偿。

### Q2：状态机为什么不把“用户结束/客服结束”做成不同状态？

**答：**

- 主状态机只表达核心阶段，避免状态爆炸
- 结束方属于审计维度，用 `HandoffEvent.eventData.endedBy` + WS payload `endedBy` 表达
- 这样对 DB 与前后端兼容成本更低，扩展更灵活。

### Q3：如何防止客服接入超出负载？

**答：**

- `acceptHandoff` 前用 `agentStatusService.canAcceptSession()` 校验
- 接入成功 `incrementSessionCount`
- 完成/用户结束 `decrementSessionCount` 释放容量。

### Q4：如果 WebSocket 消息丢了会怎样？

**答：**

- 关键状态落在 DB，用户端可通过 `getStatus` 重新拉取权威状态
- WS 只是推送加速，不是唯一信息源。

### Q5：没有客服在线怎么保证用户体验？

**答：**

- `transferToAgent` 先检查在线客服
- 无在线客服直接 `fallback` 创建工单并写入系统消息，用户立刻获得闭环。

### Q6：权限怎么做？

**答：**

- Controller 通过 `@RequireRole` 做角色隔离
- Service 层再次校验 tenantId + userId/agentId 与 request 的绑定关系，防止越权。

---

## 10. 快速索引（核心类）

- HTTP：
  - `CustomerHandoffController`
  - `AgentHandoffController`
- 业务：
  - `HandoffService`
  - `AgentAssigner`
  - `HandoffQueueService`
- WS：
  - `AgentWebSocketHandler`
  - `CustomerWebSocketHandler`
- 数据：
  - `HandoffRequest` / `HandoffEvent`
  - `HandoffRequestMapper` / `HandoffEventMapper`


