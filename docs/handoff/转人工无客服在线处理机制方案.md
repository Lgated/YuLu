# 转人工无客服在线处理机制方案

> **目标**：在你现有的转人工流程基础上，设计并实现一个健壮的兜底机制，用于处理“无客服在线”的场景，避免客户无限期等待，提升用户体验。

---

## 1. 问题分析

根据你当前的实现，当客户发起转人工请求时：

-   `HandoffService.asyncAssignAgent` 方法会尝试通过 `AgentAssigner` 寻找一位在线的客服。
-   如果 `agentStatusService.getOnlineAgents()` 返回空列表，`AgentAssigner` 会返回 `null`。
-   `HandoffService` 仅仅记录了一条日志（`"[AgentAssigner] 没有在线客服"`），然后流程就结束了。

**这会导致以下问题**：

-   客户的转人工请求 `handoff_request` 记录会一直处于 `PENDING` 状态。
-   客户在前端看到的是一直在排队，但永远不会有客服接入，因为分配器不会再处理这个请求。
-   这是一个糟糕的用户体验，客户被置于一个无人响应的“幽灵队列”中。

---

## 2. 设计目标

一个新的、健壮的处理机制应该达到以下目标：

1.  **即时反馈**：当客户申请转人工时，如果系统检测到无客服在线，应立即给予客户明确的反馈，而不是让他们进入一个无效的等待队列。
2.  **信息保全**：客户的请求和上下文信息不能丢失，必须有一个可靠的机制来记录和跟进。
3.  **流程闭环**：客户的每一次请求都应该有一个明确的终点，无论是“成功接入”还是“进入兜底流程”。
4.  **无缝集成**：兜底方案应尽可能复用你现有的工单系统和通知系统，避免引入不必要的技术复杂性。

---

## 3. 核心方案：自动转工单 (Automatic Ticket Creation)

**方案概述**：当客户发起转人工请求时，我们首先检查是否有客服在线。如果没有，则不进入排队流程，而是**立即为客户创建一个工单**，并将聊天上下文和转人工原因记录在工单中，然后明确告知客户工单已创建。

### 业务流程

```mermaid
graph TD
    A[客户点击“转人工”] --> B{HandoffService.transferToAgent};
    B --> C{检查是否有客服在线?};
    C -- 是 --> D[进入Redis排队队列<br>(当前逻辑)];
    C -- 否 --> E[**自动转工单兜底流程**];
    E --> F[1. 创建工单(Ticket)];
    F --> G[2. 创建转人工记录<br>状态: FALLBACK_TICKET];
    G --> H[3. 返回特定响应给客户<br>(告知已创建工单)];
    H --> I[4. (可选)在聊天窗口<br>插入系统消息];
```

### 状态流转

为了清晰地追踪这类请求，我们为 `HandoffStatus` 枚举增加一个最终状态：

-   `FALLBACK_TICKET`：表示该转人工请求因无客服在线，已自动转为工单处理。

这样，`handoff_request` 表就完整记录了每一次转人工尝试的最终结果。

---

## 4. 数据库与枚举变更

### 4.1 `HandoffStatus` 枚举

你需要在 `HandoffStatus.java` 枚举中增加一个新的状态。

**文件路径**: `src/main/java/com/ityfz/yulu/handoff/enums/HandoffStatus.java`

```java
public enum HandoffStatus {
    // ... (保留 PENDING, ASSIGNED, ACCEPTED 等)

    /**
     * 已转为工单（兜底）
     */
    FALLBACK_TICKET("FALLBACK_TICKET", "已转为工单");

    // ... (其他代码保持不变)
}
```

> **说明**：数据库 `handoff_request` 表的 `status` 字段是 `VARCHAR` 类型，无需修改表结构。

---

## 5. 详细代码实现

核心的修改在于 `HandoffService.transferToAgent` 方法。我们需要在请求入队前增加一个前置检查。

### 5.1 `HandoffTransferResponse` DTO 扩展

为了让前端能够区分是进入排队还是转为工单，我们需要在响应 DTO 中增加一个标志位。

**文件路径**: `src/main/java/com/ityfz/yulu/handoff/dto/HandoffTransferResponse.java`

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class HandoffTransferResponse {

    private Long handoffRequestId;
    private Long ticketId;
    private Integer queuePosition;
    private Integer estimatedWaitTime;

    /**
     * 新增：是否进入了兜底流程
     */
    private boolean fallback;

    /**
     * 新增：给前端的提示信息
     */
    private String fallbackMessage;
}
```

### 5.2 `HandoffService` 核心逻辑修改

将 `transferToAgent` 方法修改为以下实现。主要变化是增加了“无客服在线”的 `if` 分支逻辑。

**文件路径**: `src/main/java/com/ityfz/yulu/handoff/service/HandoffService.java`

```java
// ... (imports)

@Slf4j
@Service
@RequiredArgsConstructor
public class HandoffService {

    // ... (注入其他依赖)
    private final AgentStatusService agentStatusService;
    private final TicketService ticketService;

    @Transactional
    public HandoffTransferResponse transferToAgent(Long tenantId, Long userId, Long sessionId, String reason) {
        // 1. 验证会话
        ChatSession session = chatSessionMapper.selectById(sessionId);
        if (session == null || !session.getTenantId().equals(tenantId) || !session.getUserId().equals(userId)) {
            throw new BizException(ErrorCodes.UNAUTHORIZED, "会话不存在或无权限");
        }

        // 2. 检查是否已有未完成的转人工请求
        HandoffRequest existing = handoffRequestMapper.selectUncompletedBySessionId(sessionId);
        if (existing != null && !HandoffStatus.isCompleted(existing.getStatus())) {
            throw new BizException(ErrorCodes.VALIDATION_ERROR, "已有转人工请求，请勿重复申请");
        }

        // 3. 【核心变更】检查是否有客服在线
        List<Long> onlineAgents = agentStatusService.getOnlineAgents(tenantId);
        if (onlineAgents.isEmpty()) {
            log.info("[HandoffService] 租户 {} 无在线客服，执行自动转工单兜底策略", tenantId);
            return handleFallbackToTicket(tenantId, userId, session, reason);
        }

        // 4. (原逻辑) 创建工单和转人工请求
        Ticket ticket = findOrCreateTicket(tenantId, userId, sessionId, reason);
        HandoffRequest request = new HandoffRequest();
        // ... (设置 request 属性)
        request.setTenantId(tenantId);
        request.setSessionId(sessionId);
        request.setUserId(userId);
        request.setTicketId(ticket.getId());
        request.setStatus(HandoffStatus.PENDING.getCode());
        request.setReason(reason);
        request.setPriority(calculatePriority(session));
        handoffRequestMapper.insert(request);

        // 5. (原逻辑) 更新会话状态并入队
        session.setChatMode("AGENT");
        session.setHandoffRequestId(request.getId());
        chatSessionMapper.updateById(session);
        int queuePosition = queueService.addToQueue(tenantId, request.getId());
        request.setQueuePosition(queuePosition);
        handoffRequestMapper.updateById(request);

        // 6. (原逻辑) 记录事件并触发分配
        recordEvent(request.getId(), HandoffEventType.CREATED, userId, OperatorType.USER, null);
        asyncAssignAgent(tenantId, request.getId());

        // 7. (原逻辑) 返回排队信息
        int estimatedWaitTime = calculateEstimatedWaitTime(tenantId, queuePosition);
        return HandoffTransferResponse.builder()
                .handoffRequestId(request.getId())
                .ticketId(ticket.getId())
                .queuePosition(queuePosition)
                .estimatedWaitTime(estimatedWaitTime)
                .fallback(false) // 正常排队
                .build();
    }

    /**
     * 新增：处理转为工单的兜底逻辑
     */
    private HandoffTransferResponse handleFallbackToTicket(Long tenantId, Long userId, ChatSession session, String reason) {
        // 1. 创建工单
        String ticketDescription = "客户因[无客服在线]自动转为工单。转人工原因: " + (reason != null ? reason : "未提供");
        Ticket ticket = ticketService.createTicketOnNegative(tenantId, userId, session.getId(), ticketDescription, TicketPriority.HIGH.getCode());

        // 2. 创建转人工记录，状态直接设为 FALLBACK_TICKET
        HandoffRequest request = new HandoffRequest();
        request.setTenantId(tenantId);
        request.setSessionId(session.getId());
        request.setUserId(userId);
        request.setTicketId(ticket.getId());
        request.setStatus(HandoffStatus.FALLBACK_TICKET.getCode()); // 设置为兜底状态
        request.setReason(reason);
        request.setPriority(TicketPriority.HIGH.getCode());
        request.setClosedAt(LocalDateTime.now()); // 直接关闭
        handoffRequestMapper.insert(request);

        // 3. 记录事件
        recordEvent(request.getId(), HandoffEventType.FALLBACK_TICKET, userId, OperatorType.SYSTEM, null);

        // 4. (可选) 插入一条系统消息到聊天记录中
        String systemMessageContent = String.format("抱歉，当前没有客服在线。我们已经为您创建了工单 #%d，客服上线后会尽快处理您的问题。", ticket.getId());
        addSystemMessageToChat(tenantId, session.getId(), systemMessageContent);

        // 5. 返回兜底响应
        return HandoffTransferResponse.builder()
                .handoffRequestId(request.getId())
                .ticketId(ticket.getId())
                .fallback(true) // 告知前端已进入兜底
                .fallbackMessage(systemMessageContent)
                .build();
    }
    
    /**
     * 新增：添加系统消息到聊天记录
     */
    private void addSystemMessageToChat(Long tenantId, Long sessionId, String content) {
        ChatMessage systemMessage = new ChatMessage();
        systemMessage.setTenantId(tenantId);
        systemMessage.setSessionId(sessionId);
        systemMessage.setSenderType("SYSTEM"); // 需要一个 SYSTEM 类型
        systemMessage.setContent(content);
        // 如果你的 createTime 是自动填充的，这里就不需要手动设置
        chatMessageMapper.insert(systemMessage);
    }

    // ... (其他方法保持不变)
}
```

> **注意**：`addSystemMessageToChat` 方法中，`senderType` 使用了 `SYSTEM`。请确保你的 `chat_message` 表 `sender_type` 字段支持此值，或者使用 `AI` 作为替代，并在前端进行相应展示处理。

---

## 6. 前端交互建议

前端在调用 `POST /api/customer/handoff/transfer` 接口后，需要根据响应中的 `fallback` 字段来决定下一步的 UI 展示。

```typescript
// 假设在你的前端组件中

const handleTransfer = async () => {
    try {
        const response = await api.transferToAgent({ sessionId, reason });
        const data = response.data;

        if (data.fallback) {
            // 进入了兜底流程
            Modal.success({
                title: '已为您创建工单',
                content: data.fallbackMessage || `当前无客服在线，已为您创建工单 #${data.ticketId}。`,
                okText: '我知道了'
            });
            // 此时不需要建立 WebSocket 连接或显示排队信息
        } else {
            // 进入正常排队流程
            // 显示排队位置和预计等待时间...
            // 建立 WebSocket 连接来接收后续状态更新...
        }

    } catch (error) {
        message.error('转人工申请失败，请稍后再试');
    }
};
```

---

## 7. 实施步骤

1.  **更新枚举**：在 `HandoffStatus.java` 中添加 `FALLBACK_TICKET` 状态。
2.  **更新 DTO**：在 `HandoffTransferResponse.java` 中添加 `fallback` 和 `fallbackMessage` 字段。
3.  **更新 Service**：将 `HandoffService.java` 中的 `transferToAgent` 方法替换为上述新实现，并添加 `handleFallbackToTicket` 和 `addSystemMessageToChat` 两个辅助方法。
4.  **前端调整**：修改前端调用转人工接口后的回调逻辑，根据 `fallback` 字段的值，向用户展示不同的界面（排队中 vs 已创建工单）。

完成以上步骤后，你的转人工功能在“无客服在线”时将表现得更加智能和友好。



