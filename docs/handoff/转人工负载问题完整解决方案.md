# 转人工负载问题完整解决方案

## 问题现象

1. **用户端**：转人工后一直显示"排队中"，排队位置为第2位
2. **客服端**：没有收到任何转人工请求通知
3. **后端日志**：显示"没有可接入的客服（负载已满）"

## 根本原因

### 1. 客服负载计数未正确释放

从日志可以看到：
```
[AgentAssigner] 没有可接入的客服（负载已满）：tenantId=1
```

这说明客服 agentId=3 的 `current_sessions` 已经达到 `max_sessions=5`，无法接入新的会话。

**原因**：
- 之前的转人工会话没有正确结束
- `AgentStatusService.decrementSessionCount()` 没有被调用
- Redis 中的客服状态没有更新

### 2. 缺少结束会话的UI功能

客服端没有"结束会话"按钮，导致：
- 客服无法主动结束会话
- 会话一直占用负载配额
- 新的请求无法分配

### 3. WebSocket 连接不稳定

前端日志显示：
```
[vite] ws proxy socket error: Error: write ECONNABORTED
[vite] ws proxy socket error: Error: read ECONNRESET
```

这可能导致：
- 客服状态管理混乱
- 消息无法正常发送
- 连接频繁断开重连

## 完整解决方案

### 步骤1：清理 Redis 中的客服负载状态（立即执行）

#### 1.1 使用 Redis 客户端工具

推荐使用以下工具之一：
- **RedisInsight**（官方推荐）：https://redis.io/insight/
- **Another Redis Desktop Manager**：https://github.com/qishibo/AnotherRedisDesktopManager
- **Redis Desktop Manager**

#### 1.2 连接到 Redis

- Host: localhost
- Port: 6379
- Password: （如果有的话）

#### 1.3 执行清理命令

**方法A：删除客服状态（推荐）**

```redis
# 删除客服状态
DEL agent:status:1:3

# 客服下次心跳时会自动重新创建，current_sessions 会重置为 0
```

**方法B：手动修改状态**

```redis
# 查看当前状态
GET agent:status:1:3

# 手动设置为 0
SET agent:status:1:3 '{"status":"ONLINE","current_sessions":0,"max_sessions":5,"last_heartbeat":"2026-02-09T13:35:00"}'
```

**方法C：使用 Java 代码临时修复（如果无法访问 Redis）**

创建一个临时的 REST 接口：

```java
@RestController
@RequestMapping("/api/admin/debug")
@RequireRole("ADMIN")
public class DebugController {
    
    @Autowired
    private AgentStatusService agentStatusService;
    
    @PostMapping("/reset-agent-load/{agentId}")
    public ApiResponse<Void> resetAgentLoad(@PathVariable Long agentId) {
        Long tenantId = SecurityUtil.currentTenantId();
        
        // 重置客服负载
        agentStatusService.resetSessionCount(tenantId, agentId);
        
        return ApiResponse.success("客服负载已重置");
    }
}
```

然后在 `AgentStatusService` 中添加方法：

```java
public void resetSessionCount(Long tenantId, Long agentId) {
    String key = buildStatusKey(tenantId, agentId);
    
    // 获取当前状态
    Map<String, Object> status = getAgentStatus(tenantId, agentId);
    
    // 重置 current_sessions
    status.put("current_sessions", 0);
    
    // 保存回 Redis
    redisTemplate.opsForValue().set(key, JSON.toJSONString(status), 1, TimeUnit.HOURS);
    
    log.info("[AgentStatus] 已重置客服负载：tenantId={}, agentId={}", tenantId, agentId);
}
```

#### 1.4 清理排队队列（可选）

如果队列中有很多旧的请求：

```redis
# 查看队列
LRANGE handoff:queue:1 0 -1

# 清空队列（谨慎使用！）
DEL handoff:queue:1
```

### 步骤2：添加客服端"结束会话"功能（已完成）

我已经修改了以下文件：

1. **frontend/src/components/AgentChatWindow.tsx**
   - 添加了"结束会话"按钮
   - 添加了确认对话框
   - 调用 `handoffApi.complete()` 结束会话

2. **frontend/src/pages/agent/AgentWorkbenchPage.tsx**
   - 添加了 `handleEndSession` 方法
   - 监听 `HANDOFF_COMPLETED` WebSocket 消息
   - 自动从活动会话列表中移除已结束的会话

3. **frontend/src/api/handoff.ts**
   - 已经有 `complete()` 方法，无需修改

### 步骤3：修复 WebSocket 连接问题

#### 3.1 前端 WebSocket 重连机制优化

当前的 WebSocket 客户端已经有重连机制，但可能需要优化：

```typescript
// frontend/src/utils/websocket.ts

// 修改重连延迟，避免频繁重连
private scheduleReconnect() {
  if (this.reconnectTimer) return;
  this.reconnectTimer = setTimeout(() => {
    console.log('[WebSocket] Reconnecting...');
    this.connect();
  }, 5000); // 从 5 秒改为 10 秒
}
```

#### 3.2 后端 WebSocket 并发问题修复

添加同步锁，避免并发发送消息导致的错误：

```java
// AgentWebSocketHandler.java

private final Map<String, Object> sessionLocks = new ConcurrentHashMap<>();

public synchronized void sendToAgent(Long tenantId, Long agentId, WebSocketMessage message) {
    String connectionKey = buildConnectionKey(tenantId, agentId);
    WebSocketSession session = agentSessions.get(connectionKey);

    if (session != null && session.isOpen()) {
        // 获取会话锁
        Object lock = sessionLocks.computeIfAbsent(connectionKey, k -> new Object());
        
        synchronized (lock) {
            try {
                String json = objectMapper.writeValueAsString(message);
                session.sendMessage(new TextMessage(json));
                log.debug("[WebSocket] 发送消息给客服：connectionKey={}, type={}", 
                    connectionKey, message.getType());
            } catch (Exception e) {
                log.error("[WebSocket] 发送消息给客服失败：connectionKey={}", connectionKey, e);
            }
        }
    } else {
        log.warn("[WebSocket] 客服连接不存在或已关闭：connectionKey={}", connectionKey);
    }
}

@Override
public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
    // 清理连接
    Long agentId = (Long) session.getAttributes().get("userId");
    Long tenantId = (Long) session.getAttributes().get("tenantId");

    if (agentId != null && tenantId != null) {
        String connectionKey = buildConnectionKey(tenantId, agentId);
        agentSessions.remove(connectionKey);
        sessionLocks.remove(connectionKey); // 清理锁
        log.info("[WebSocket] 客服连接关闭：connectionKey={}, status={}", connectionKey, status);
    }
}
```

同样的修改也应用到 `CustomerWebSocketHandler.java`。

### 步骤4：添加客服负载自动恢复机制

#### 4.1 添加定时任务，定期检查和修复负载状态

```java
@Component
@Slf4j
public class AgentLoadRecoveryTask {
    
    @Autowired
    private AgentStatusService agentStatusService;
    
    @Autowired
    private HandoffRequestMapper handoffRequestMapper;
    
    @Autowired
    private ChatSessionMapper chatSessionMapper;
    
    /**
     * 每5分钟检查一次客服负载状态
     */
    @Scheduled(fixedRate = 300000) // 5分钟
    public void checkAndRecoverAgentLoad() {
        log.info("[AgentLoadRecovery] 开始检查客服负载状态");
        
        // 获取所有在线客服
        // TODO: 需要实现获取所有租户的方法
        List<Long> tenantIds = getTenantIds();
        
        for (Long tenantId : tenantIds) {
            List<Long> onlineAgents = agentStatusService.getOnlineAgents(tenantId);
            
            for (Long agentId : onlineAgents) {
                try {
                    recoverAgentLoad(tenantId, agentId);
                } catch (Exception e) {
                    log.error("[AgentLoadRecovery] 恢复客服负载失败：tenantId={}, agentId={}", 
                        tenantId, agentId, e);
                }
            }
        }
        
        log.info("[AgentLoadRecovery] 客服负载状态检查完成");
    }
    
    private void recoverAgentLoad(Long tenantId, Long agentId) {
        // 1. 获取 Redis 中的负载状态
        Map<String, Object> status = agentStatusService.getAgentStatus(tenantId, agentId);
        Integer currentSessions = (Integer) status.getOrDefault("current_sessions", 0);
        
        // 2. 查询数据库中实际的活跃会话数
        Long actualSessions = chatSessionMapper.selectCount(Wrappers.<ChatSession>lambdaQuery()
            .eq(ChatSession::getTenantId, tenantId)
            .eq(ChatSession::getAgentId, agentId)
            .eq(ChatSession::getChatMode, "AGENT")
            .in(ChatSession::getStatus, 1) // 活跃状态
        );
        
        // 3. 如果不一致，修复
        if (!currentSessions.equals(actualSessions.intValue())) {
            log.warn("[AgentLoadRecovery] 发现负载不一致：tenantId={}, agentId={}, " +
                "Redis={}, DB={}", tenantId, agentId, currentSessions, actualSessions);
            
            // 更新 Redis
            status.put("current_sessions", actualSessions.intValue());
            agentStatusService.updateAgentStatus(tenantId, agentId, status);
            
            log.info("[AgentLoadRecovery] 已修复负载：tenantId={}, agentId={}, " +
                "修正为={}", tenantId, agentId, actualSessions);
        }
    }
    
    private List<Long> getTenantIds() {
        // TODO: 实现获取所有租户ID的方法
        // 可以从数据库查询，或者维护一个租户列表
        return Arrays.asList(1L); // 临时返回租户1
    }
}
```

#### 4.2 在 AgentStatusService 中添加更新方法

```java
public void updateAgentStatus(Long tenantId, Long agentId, Map<String, Object> status) {
    String key = buildStatusKey(tenantId, agentId);
    redisTemplate.opsForValue().set(key, JSON.toJSONString(status), 1, TimeUnit.HOURS);
}
```

### 步骤5：添加更详细的日志

在关键位置添加日志，便于排查问题：

```java
// HandoffService.acceptHandoff()
log.info("[HandoffService] 客服接受请求：tenantId={}, agentId={}, handoffRequestId={}, sessionId={}", 
    tenantId, agentId, handoffRequestId, request.getSessionId());

// HandoffService.complete()
log.info("[HandoffService] 客服完成对话：tenantId={}, agentId={}, handoffRequestId={}, sessionId={}", 
    tenantId, agentId, handoffRequestId, request.getSessionId());

// AgentStatusService.incrementSessionCount()
log.info("[AgentStatus] 增加客服会话数：tenantId={}, agentId={}, before={}, after={}", 
    tenantId, agentId, currentSessions, currentSessions + 1);

// AgentStatusService.decrementSessionCount()
log.info("[AgentStatus] 减少客服会话数：tenantId={}, agentId={}, before={}, after={}", 
    tenantId, agentId, currentSessions, currentSessions - 1);
```

## 执行步骤总结

### 立即执行（解决当前问题）

1. **清理 Redis 客服状态**
   ```redis
   DEL agent:status:1:3
   ```

2. **清理排队队列（可选）**
   ```redis
   DEL handoff:queue:1
   ```

3. **重启客服端浏览器**
   - 刷新客服工作台页面
   - 客服会重新上线，负载重置为 0

4. **测试转人工功能**
   - 用户端发起转人工请求
   - 客服端应该能收到通知
   - 客服接受后能正常通信

### 后续优化（防止问题再次发生）

1. **部署前端代码**
   - 包含"结束会话"按钮的修改
   - WebSocket 监听 `HANDOFF_COMPLETED` 消息

2. **部署后端代码**
   - WebSocket 并发锁修复
   - 添加负载恢复定时任务
   - 添加详细日志

3. **配置监控告警**
   - 监控客服负载状态
   - 当负载异常时发送告警
   - 定期检查 Redis 和数据库的一致性

## 验证步骤

### 1. 验证客服负载已重置

```redis
GET agent:status:1:3
```

应该返回：
```json
{
  "status": "ONLINE",
  "current_sessions": 0,
  "max_sessions": 5,
  "last_heartbeat": "2026-02-09T14:00:00"
}
```

### 2. 验证转人工流程

1. 用户端发起转人工请求
2. 后端日志应该显示：
   ```
   [AgentAssigner] 分配客服成功：handoffRequestId=xxx, agentId=3, score=xxx
   [HandoffService] 已更新会话的客服ID：sessionId=xxx, agentId=3
   [HandoffService] 转人工请求通知已发送：agentId=3, handoffRequestId=xxx
   ```

3. 客服端应该收到通知
4. 客服接受后能正常通信
5. 客服点击"结束会话"按钮
6. 用户端收到"对话已结束"通知
7. 客服负载减1

### 3. 验证负载计数

```redis
GET agent:status:1:3
```

应该看到 `current_sessions` 正确增减。

## 常见问题

### Q1: 清理 Redis 后，客服还是无法接入？

**A**: 检查以下几点：
1. 客服是否在线？查看 `agent:status:1:3` 的 `status` 字段
2. 客服是否有配置？查询 `agent_config` 表
3. 是否有其他错误？查看后端日志

### Q2: WebSocket 还是频繁断开？

**A**: 可能的原因：
1. 网络不稳定
2. 代理服务器超时设置太短
3. 前端心跳间隔太长

解决方法：
- 缩短心跳间隔（从30秒改为15秒）
- 配置 Nginx 的 WebSocket 超时时间
- 检查防火墙设置

### Q3: 负载计数还是不准确？

**A**: 启用定时任务自动修复：
- 确保 `@EnableScheduling` 已启用
- 检查定时任务日志
- 手动触发一次恢复任务

## 总结

本次问题的根本原因是**客服负载计数未正确释放**，导致新的转人工请求无法分配。

解决方案包括：
1. ✅ 立即清理 Redis 状态（临时解决）
2. ✅ 添加"结束会话"功能（根本解决）
3. ✅ 修复 WebSocket 并发问题（稳定性提升）
4. ✅ 添加负载自动恢复机制（防止复发）

完成以上步骤后，转人工功能应该能够正常工作。
