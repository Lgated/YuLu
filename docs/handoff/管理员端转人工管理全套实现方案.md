# 管理员端转人工管理 - 全套后端实现方案

本方案专为**租户管理员（Tenant Admin）**设计，支持对本租户内的转人工记录进行查询、客服状态实时监控以及运营通知广播。

- **权限模型**：基于租户隔离，管理员仅能操作所属租户的数据。
- **状态存储**：客服实时状态读取自 **Redis**（对接现有的 `AgentStatusService`）。
- **实现范围**：DTO、VO、Service、Controller 及 WebSocket 扩展建议。

---

## 一、 数据传输对象 (DTO & VO)

在 `com.ityfz.yulu.handoff.admin`（或相应目录）下创建以下类。

### 1.1 查询与操作 DTO

```java
// HandoffRecordQueryDTO.java - 记录分页查询
@Data
public class HandoffRecordQueryDTO {
    private Long userId;
    private Long agentId;
    private String status;
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startTime;
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime endTime;
    private Integer pageNo = 1;
    private Integer pageSize = 20;
}

// AdminNotifyDTO.java - 广播通知
@Data
public class AdminNotifyDTO {
    @NotBlank(message = "标题不能为空")
    private String title;
    @NotBlank(message = "内容不能为空")
    private String content;
}

// ForceAgentStatusDTO.java - 强制修改状态
@Data
public class ForceAgentStatusDTO {
    @NotBlank(message = "状态不能为空")
    private String status; // ONLINE, AWAY, OFFLINE
}
```

### 1.2 展示用 VO

```java
// HandoffRecordVO.java - 转人工记录详情
@Data
@Builder
public class HandoffRecordVO {
    private Long handoffRequestId;
    private Long sessionId;
    private Long userId;
    private String userName;
    private Long agentId;
    private String agentName;
    private Long ticketId;
    private String status;
    private String priority;
    private LocalDateTime createdAt;
    private LocalDateTime acceptedAt;
    private LocalDateTime completedAt;
    private Long waitDurationSeconds; // 等待耗时
    private Long chatDurationSeconds; // 通话耗时
}

// AgentMonitorVO.java - 客服实时状态看板
@Data
@Builder
public class AgentMonitorVO {
    private Long agentId;
    private String agentName;
    private String status;         // 来自 Redis
    private Integer currentSessions; // 来自 Redis
    private Integer maxSessions;
    private LocalDateTime lastActiveTime;
}
```

---

## 二、 业务逻辑层 (Service)

### 2.1 AdminHandoffService (记录与统计)

```java
@Service
@RequiredArgsConstructor
public class AdminHandoffService {
    private final HandoffRequestMapper handoffRequestMapper;
    private final HandoffEventMapper handoffEventMapper;

    /**
     * 分页查询本租户转人工记录
     */
    public Page<HandoffRecordVO> queryRecords(Long tenantId, HandoffRecordQueryDTO query) {
        LambdaQueryWrapper<HandoffRequest> qw = new LambdaQueryWrapper<HandoffRequest>()
                .eq(HandoffRequest::getTenantId, tenantId)
                .eq(query.getUserId() != null, HandoffRequest::getUserId, query.getUserId())
                .eq(query.getAgentId() != null, HandoffRequest::getAgentId, query.getAgentId())
                .eq(StringUtils.hasText(query.getStatus()), HandoffRequest::getStatus, query.getStatus())
                .ge(query.getStartTime() != null, HandoffRequest::getCreateTime, query.getStartTime())
                .le(query.getEndTime() != null, HandoffRequest::getCreateTime, query.getEndTime())
                .orderByDesc(HandoffRequest::getCreateTime);

        Page<HandoffRequest> page = handoffRequestMapper.selectPage(new Page<>(query.getPageNo(), query.getPageSize()), qw);
        
        List<HandoffRecordVO> vos = page.getRecords().stream().map(this::convertToVO).collect(Collectors.toList());
        Page<HandoffRecordVO> voPage = new Page<>(page.getCurrent(), page.getSize(), page.getTotal());
        voPage.setRecords(vos);
        return voPage;
    }

    private HandoffRecordVO convertToVO(HandoffRequest req) {
        Long wait = (req.getAcceptedAt() != null) ? Duration.between(req.getCreateTime(), req.getAcceptedAt()).getSeconds() : null;
        Long chat = (req.getCompletedAt() != null && req.getAcceptedAt() != null) ? Duration.between(req.getAcceptedAt(), req.getCompletedAt()).getSeconds() : null;
        
        return HandoffRecordVO.builder()
                .handoffRequestId(req.getId())
                .sessionId(req.getSessionId())
                .userId(req.getUserId())
                .userName("客户#" + req.getUserId())
                .agentId(req.getAgentId())
                .agentName(req.getAgentId() != null ? "客服#" + req.getAgentId() : "未分配")
                .status(req.getStatus())
                .createdAt(req.getCreateTime())
                .acceptedAt(req.getAcceptedAt())
                .completedAt(req.getCompletedAt())
                .waitDurationSeconds(wait)
                .chatDurationSeconds(chat)
                .build();
    }
}
```

### 2.2 AdminAgentManagementService (客服看板与管控)

该 Service 重点在于对接你现有的 Redis 逻辑。

```java
@Service
@RequiredArgsConstructor
public class AdminAgentManagementService {
    private final AgentStatusService agentStatusService;
    private final AgentWebSocketHandler agentHandler;

    /**
     * 获取租户内所有客服的实时监控数据
     */
    public List<AgentMonitorVO> getAgentMonitorList(Long tenantId) {
        // 1. 调用你现有的 AgentStatusService 获取 Redis 里的实时数据
        // 假设 AgentStatusService 已经实现了获取全量状态的方法
        return agentStatusService.getRealtimeMonitors(tenantId);
    }

    /**
     * 强制修改客服状态并同步通知
     */
    public void forceUpdateAgentStatus(Long tenantId, Long agentId, String newStatus) {
        // 1. 修改 Redis 状态
        agentStatusService.updateStatus(tenantId, agentId, newStatus);
        
        // 2. 发送 WebSocket 强制指令到客服端 UI
        Map<String, Object> payload = new HashMap<>();
        payload.put("status", newStatus);
        
        WebSocketMessage msg = WebSocketMessage.builder()
                .type("ADMIN_FORCE_STATUS")
                .payload(payload)
                .timestamp(LocalDateTime.now().toString())
                .build();
        
        agentHandler.sendToAgent(tenantId, agentId, msg);
    }

    /**
     * 广播通知
     */
    public void broadcastNotification(Long tenantId, String title, String content) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("title", title);
        payload.put("content", content);
        
        WebSocketMessage msg = WebSocketMessage.builder()
                .type("ADMIN_NOTIFICATION")
                .payload(payload)
                .timestamp(LocalDateTime.now().toString())
                .build();
        
        // 在 AgentWebSocketHandler 中实现按租户广播
        agentHandler.broadcastToTenant(tenantId, msg);
    }
}
```

---

## 三、 控制层 (Controller)

使用 `@RequireRole("ADMIN")` 确保仅租户管理员可访问。

```java
@RestController
@RequestMapping("/api/admin/handoff")
@RequiredArgsConstructor
@Validated
@RequireRole("ADMIN")
public class AdminHandoffController {
    
    private final AdminHandoffService adminHandoffService;
    private final AdminAgentManagementService adminAgentService;

    @GetMapping("/records")
    public ApiResponse<Page<HandoffRecordVO>> getRecords(HandoffRecordQueryDTO query) {
        Long tenantId = SecurityUtil.currentTenantId();
        return ApiResponse.success(adminHandoffService.queryRecords(tenantId, query));
    }

    @GetMapping("/agent/status")
    public ApiResponse<List<AgentMonitorVO>> getAgentStatus() {
        Long tenantId = SecurityUtil.currentTenantId();
        return ApiResponse.success(adminAgentService.getAgentMonitorList(tenantId));
    }

    @PostMapping("/agent/{agentId}/status")
    public ApiResponse<Void> forceStatus(@PathVariable Long agentId, @RequestBody ForceAgentStatusDTO dto) {
        Long tenantId = SecurityUtil.currentTenantId();
        adminAgentService.forceUpdateAgentStatus(tenantId, agentId, dto.getStatus());
        return ApiResponse.success("状态已强制更新");
    }

    @PostMapping("/notify")
    public ApiResponse<Void> sendNotify(@RequestBody AdminNotifyDTO dto) {
        Long tenantId = SecurityUtil.currentTenantId();
        adminAgentService.broadcastNotification(tenantId, dto.getTitle(), dto.getContent());
        return ApiResponse.success("通知已下发");
    }
}
```

---

## 四、 关键基础设施扩展

为了支撑上述功能，你需要对 `AgentWebSocketHandler` 进行微调：

### 4.1 AgentWebSocketHandler 增加广播

```java
public void broadcastToTenant(Long tenantId, WebSocketMessage message) {
    // 遍历当前在线的 Session，过滤出属于该 tenantId 的 session 发送
    // 逻辑示例：
    // sessionMap.values().stream()
    //    .filter(s -> tenantId.equals(s.getTenantId()))
    //    .forEach(s -> s.send(message));
}
```

---

## 五、 实现步骤总结

1. **新建包结构**：创建 `com.ityfz.yulu.handoff.admin` 及其子包 `dto, vo, service, controller`。
2. **定义 DTO/VO**：按照本文档第一部分定义数据结构，确保字段与数据库、Redis 存储一致。
3. **实现 Service**：
   - `AdminHandoffService` 负责从 DB (`handoff_request`) 读历史记录。
   - `AdminAgentManagementService` 负责从 Redis 读客服实时状态并控制 WS 推送。
4. **接入 Controller**：配置请求路径，并使用 `SecurityUtil` 获取当前管理员的租户 ID。
5. **WS 扩展**：确保 `AgentWebSocketHandler` 能够按租户下发消息。
6. **前端对接**：管理员页面调用这些接口，展示转人工列表、统计报表及客服看板。


