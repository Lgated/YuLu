# 为什么C端需要租户校验？逻辑说明

## 🤔 问题：为什么C端用户登录还需要租户标识？

**核心原因：多租户系统的数据隔离机制**

---

## 📊 一、多租户系统的数据隔离

### 1.1 数据库结构

在你的系统中，所有业务数据都带有 `tenant_id` 字段：

```sql
-- user 表结构
CREATE TABLE user (
    id BIGINT PRIMARY KEY,
    tenant_id BIGINT NOT NULL,  -- 租户ID
    username VARCHAR(64),       -- 用户名
    password VARCHAR(255),
    ...
);

-- 数据示例
| id | tenant_id | username | password |
|----|-----------|----------|----------|
| 1  | 1         | 张三     | xxx      |  -- 租户1的用户
| 2  | 2         | 张三     | yyy      |  -- 租户2的用户（同名）
| 3  | 1         | 李四     | zzz      |  -- 租户1的用户
```

### 1.2 问题场景

**场景1：用户名可能重复**
- 租户A（教育机构）有一个用户叫"张三"
- 租户B（电商公司）也有一个用户叫"张三"
- 如果只输入用户名"张三"和密码，系统无法知道要查询哪个租户下的用户

**场景2：数据隔离**
- 租户A的用户只能看到租户A的数据
- 租户B的用户只能看到租户B的数据
- 必须通过 `tenant_id` 来隔离数据

---

## 🔍 二、登录时的查询逻辑

### 2.1 如果不指定租户，会发生什么？

```java
// ❌ 错误的查询方式（不指定租户）
User user = userMapper.selectOne(
    new LambdaQueryWrapper<User>()
        .eq(User::getUsername, "张三")  // 只根据用户名查询
        .eq(User::getPassword, "xxx")
);
```

**问题**：
- 如果多个租户都有用户"张三"，查询会返回多条记录
- 系统无法确定用户属于哪个租户
- 可能导致数据泄露（用户A登录后看到用户B的数据）

### 2.2 正确的查询方式（必须指定租户）

```java
// ✅ 正确的查询方式（指定租户）
User user = userMapper.selectOne(
    new LambdaQueryWrapper<User>()
        .eq(User::getTenantId, 1)      // 必须指定租户ID
        .eq(User::getUsername, "张三")
        .eq(User::getPassword, "xxx")
);
```

**好处**：
- 精确查询到特定租户下的用户
- 确保数据隔离
- 避免数据泄露

---

## 💡 三、为什么C端用户不需要知道租户信息？

### 3.1 用户视角 vs 系统视角

**用户视角**：
- 用户只知道自己属于某个公司/机构
- 用户不需要知道"租户ID"、"租户编码"这些技术概念
- 用户只需要输入：用户名 + 密码

**系统视角**：
- 系统必须知道用户属于哪个租户
- 系统需要通过租户ID来查询和隔离数据
- 系统需要租户标识来区分不同租户的用户

### 3.2 解决方案：隐式传递租户标识

**方式1：URL参数（推荐）**
```
用户点击链接：https://yulu.com/login?tenant=EDU_001
↓
系统自动从URL参数获取租户标识：EDU_001
↓
系统查询租户表，找到 tenant_identifier='EDU_001' 的租户，获取 tenant_id=1
↓
系统查询用户：WHERE tenant_id=1 AND username='张三'
```

**方式2：请求头**
```
前端axios拦截器自动设置：X-Tenant-Identifier: EDU_001
↓
后端从请求头获取租户标识
↓
系统查询租户和用户（同上）
```

**关键点**：
- ✅ 用户**不需要**输入租户标识（页面不显示）
- ✅ 租户标识通过**技术手段**自动传递（URL参数、请求头）
- ✅ 用户**无感知**，体验就像单租户系统

---

## 🎯 四、完整的登录流程

### 4.1 C端登录流程（用户无感知）

```
1. 租户在自己的网站放置登录链接
   <a href="https://yulu.com/login?tenant=EDU_001">客户登录</a>

2. 用户点击链接
   → 浏览器跳转到：https://yulu.com/login?tenant=EDU_001
   → 租户标识自动保存在URL参数中

3. 用户看到登录页面
   → 只显示：用户名、密码（不显示租户标识）
   → 用户输入：用户名="张三"，密码="xxx"

4. 前端发送登录请求
   → POST /api/customer/auth/login?tenant=EDU_001
   → Body: { username: "张三", password: "xxx" }

5. 后端处理
   → 从URL参数获取 tenant="EDU_001"
   → 查询租户表：SELECT * FROM tenant WHERE tenant_identifier='EDU_001'
   → 获取 tenant_id=1
   → 查询用户：SELECT * FROM user WHERE tenant_id=1 AND username='张三'
   → 验证密码
   → 返回Token

6. 登录成功
   → 用户进入系统，只能看到租户1的数据
```

### 4.2 关键点总结

| 环节 | 用户是否知道租户？ | 系统是否知道租户？ |
|------|------------------|-------------------|
| 点击链接 | ❌ 不知道（只是点击链接） | ✅ 知道（URL参数） |
| 输入信息 | ❌ 不知道（只输入用户名密码） | ✅ 知道（从URL参数获取） |
| 登录验证 | ❌ 不知道 | ✅ 知道（必须知道才能查询） |
| 使用系统 | ❌ 不知道 | ✅ 知道（Token中包含tenantId） |

---

## 🔐 五、为什么必须校验租户？

### 5.1 数据安全

**如果不校验租户**：
```java
// 危险：不指定租户查询用户
User user = userMapper.selectOne(
    new LambdaQueryWrapper<User>()
        .eq(User::getUsername, "张三")
);
// 可能返回租户A的用户，也可能返回租户B的用户
// 如果返回了租户B的用户，用户A就能看到租户B的数据（数据泄露！）
```

**如果校验租户**：
```java
// 安全：指定租户查询用户
User user = userMapper.selectOne(
    new LambdaQueryWrapper<User>()
        .eq(User::getTenantId, 1)  // 明确指定租户
        .eq(User::getUsername, "张三")
);
// 只能查询到租户1的用户，确保数据隔离
```

### 5.2 业务逻辑

- **多租户系统**：一个系统服务多个租户（公司/机构）
- **数据隔离**：不同租户的数据必须完全隔离
- **用户归属**：每个用户必须属于某个租户
- **查询必须**：查询用户时必须指定租户，否则无法确定用户归属

---

## 📝 六、总结

### 6.1 为什么需要租户标识？

1. **数据隔离**：不同租户的数据必须隔离
2. **用户名可能重复**：不同租户可能有相同的用户名
3. **查询必须**：查询用户时必须指定租户ID
4. **安全要求**：防止数据泄露

### 6.2 为什么用户不需要知道？

1. **用户体验**：用户不应该知道技术细节（tenant_id、tenant_code）
2. **隐式传递**：通过URL参数或请求头自动传递
3. **无感知**：用户只输入用户名和密码，体验像单租户系统

### 6.3 实现方式

1. **URL参数**：`/login?tenant=EDU_001`（推荐）
2. **请求头**：`X-Tenant-Identifier: EDU_001`
3. **自动处理**：前端自动设置，后端自动识别

---

## 🎯 七、类比理解

**类比：学校系统**

- **多租户系统** = 一个系统服务多个学校
- **租户** = 学校（A学校、B学校）
- **用户** = 学生（A学校有学生"张三"，B学校也有学生"张三"）
- **租户标识** = 学校标识（A学校、B学校）

**登录流程**：
1. 学生访问自己学校的登录页面（URL中自动带上学校标识）
2. 学生输入学号和密码
3. 系统根据学校标识和学号查询学生
4. 学生只能看到自己学校的数据

**关键点**：
- 学生不需要输入"我是A学校的学生"（系统自动知道）
- 但系统必须知道学生属于哪个学校（才能查询到正确的学生）

---

**文档版本**：v1.0  
**创建时间**：2026-01-14

















