# 知识库索引与检索服务（RAG-Index & Retrieval）完整实现指南【对齐你现有代码】

> 已对齐你贴出的实体/Mapper/QdrantVectorStore：  
> - Document: `status`(0/1/2), `indexedAt`, `fileType`, `fileSize`, `tenantId`  
> - Chunk: `chunkIndex`（序号，从0开始）、`qdrantPointId`、`tenantId`、`content`  
> - Mapper: `DocumentMapper.selectByTenantIdAndId`，`ChunkMapper.listByDocumentIdAndTenantId`  
> - QdrantVectorStore：`createCollection`，`upsertPoint(collection, long pointId, List<Float> vector, Map<String,Object> payload)`，`search(collection, queryVector, topK, Points.Filter filter)`，`objectToValue(Object)`（返回 JsonWithInt.Value）

---

## 0. 你要最终实现的能力（验收清单）

- **索引（Index）**
  - **按文档**将其下所有 `Chunk` 批量向量化
  - 写入 Qdrant collection（upsert）
  - 写入/更新 payload（文档/段落/租户/来源等元数据）
  - 在 DB 中维护映射关系：`Chunk.qdrantPointId`、`Document.indexedAt`、`Document.status`
  - 支持**幂等**：同一 chunk 反复索引不会产生重复点（upsert 覆盖）
  - 支持**重建索引**：按文档删除旧点再重建（可选）

- **检索（Retrieval）**
  1. 用户问题向量化（Embedding）
  2. Qdrant Top-K 相似检索（按 tenant 过滤）
  3. 按 score 排序 + 阈值过滤
  4. 返回检索结果：**chunk 内容 + score + 文档元信息（title/source/fileType）+ chunk 位置信息（orderNo）**

- **可观测性**
  - 打印检索命中的 payload 核心字段（不要打印太长 chunk）
  - 当 Qdrant 不可用时，提供清晰错误信息（便于排查）

---

## 1. 核心概念与知识点（必须理解）

### 1.1 Embedding 向量维度必须一致（非常关键）

- 每个 embedding 模型输出固定维度向量，例如 `text-embedding-v2` 常见维度：`1024`（以你项目配置为准）。
- **Qdrant collection 创建时必须指定向量维度 size**。如果 size 与 embedding 输出维度不一致：
  - upsert 会失败，或写入后检索异常
  - 这是最常见的“写不进去/查不到”的根因之一

> 结论：`EmbeddingService.getDimension()` 与 `Qdrant collection vector size` 必须一致。

### 1.2 Qdrant 的 3 个核心对象（结合你现有 QdrantVectorStore）

- **Collection**
  - 相当于“一个向量表/索引空间”
  - 需要配置：向量维度、距离度量（Cosine/Dot/Euclid）、可选分片与副本

- **Point**
  - 每条向量数据：`point_id + vector + payload`
  - `point_id`：可以是数字（long）或 UUID（看客户端支持）
  - `vector`：List<Float> 向量、
- 
  - `payload`：结构化元数据（可过滤、可返回）



- **Payload**
  - 你放到 Qdrant 的“元数据”
  - 典型用途：
    - 多租户过滤：`tenant_id`
    - 与 DB 映射：`document_id`、`chunk_id`
    - 返回更多信息：`title`、`source`、`order_no` 等


### 1.3 距离度量（Distance）怎么选？

- **Cosine**：最常见文本向量相似度，默认推荐
- **Dot**：如果向量已归一化，Dot ~ Cosine；一些系统偏好 Dot
- **Euclid**：文本检索少用

> 推荐：`Cosine`（你若已在现有 `QdrantVectorStore` 使用 Cosine，就保持一致）。

### 1.4 Top-K 与阈值（minScore）

- Top-K：返回最相似的 K 条
- minScore：过滤掉相似度太低的结果（减少“看似相关其实不相关”）

经验值（仅参考，需要你按语料调参）：
- `topK=5~20`
- `minScore=0.25~0.55`（Cosine 情况下，受模型与文本影响很大）

### 1.5 幂等索引策略（推荐：point_id = chunkId）

为了避免重复写入同一 chunk，最简单策略：
- Qdrant `point_id` 直接使用 `Chunk.id`
- upsert 时重复写会覆盖，天然幂等

这样 DB 中 `Chunk.qdrantPointId` 可直接写 `chunkId`（或冗余存一份）。

---

## 2. 建议的元数据（payload）规范（推荐落地）

以下 payload 字段是**够用且易扩展**的一组：

- `tenant_id`：租户 ID（过滤必备）
- `document_id`：文档 ID（映射必备）
- `chunk_id`：chunk ID（映射必备）
- `order_no`：chunk 顺序号（拼接上下文/定位必备）
- `title`：文档标题（返回给前端）
- `source`：文档来源/上传来源（返回给前端）
- `file_type`：文档类型（返回给前端）
- `chunk`：chunk 文本内容（检索返回用）
  - 注意：payload 不建议放超长文本，可截断（例如 2000-4000 字符）

> **为什么 payload 里还要放 chunk 文本？**  
> 因为检索结果如果只返回 chunk_id，还要回库查内容，接口会多一次 DB 访问。小规模系统可回库；为了简单闭环和低延迟，payload 内保留 chunk 文本非常实用（但要注意大小）。

---

## 3. 索引（Index）服务：从 DB 到 Qdrant 的完整流程

### 3.1 索引服务的职责拆分（推荐）

- `ChunkIndexService`
  - 承担：按文档（或批量）索引 chunk
  - 核心动作：查 chunk → 批量 embedding → upsert → 更新 DB 映射/状态

- `QdrantVectorStore`
  - 承担：Qdrant CRUD（createCollection/upsert/search/delete）

- `EmbeddingService`（你已实现 DashScope）
  - 承担：单条/批量向量化

### 3.2 索引状态与字段（按你现有表）

- `Document.status`：0-未索引，1-已索引，2-索引失败  
- `Document.indexedAt`：索引时间  
- `Chunk.qdrantPointId`：Qdrant pointId（建议用 chunkId 作为 pointId，天然幂等）

### 3.3 索引步骤（按文档，匹配你现有 Mapper）

1. 校验文档存在且属于当前租户：`DocumentMapper.selectByTenantIdAndId`
2. 查询该文档的 chunk：`ChunkMapper.listByDocumentIdAndTenantId(documentId, tenantId)`
3. 批量 embedding：`embedBatch(texts)`
4. 组装 Qdrant Points：
   - pointId：`chunkId`
   - vector：embedding 向量
   - payload：tenant/document/chunk/order/title/source/fileType/chunk...
5. upsert 写入 Qdrant
6. DB 更新：
   - `Chunk.qdrantPointId = chunkId`
   - `Document.indexedAt = now()`
   - `Document.status = INDEXED`
7. 异常处理：
   - Qdrant/Embedding 失败：`status=INDEX_FAILED`，记录错误原因日志（可扩展 errorMsg 字段）

---

## 4. 检索（Retrieval）服务：从用户问题到检索结果的完整流程

### 4.1 检索步骤

1. 输入：`query`、`tenantId`、`topK`、`minScore`
2. `EmbeddingService.embed(query)` 得到 query vector
3. Qdrant search：
   - collection：`yulu_chunks`（示例）
   - filter：`tenant_id == 当前租户`
   - withPayload：true（为了返回 chunk 与元数据）
4. 对返回 `ScoredPoint`：
   - 按 score 倒序（Qdrant 通常已按相似度排序，但你可以再排序确保）
   - 过滤：score < minScore 丢弃
5. 输出：`RetrievalResultDTO` 列表（含 score + 文本 + 元数据）

---

## 5. 关键代码（可直接照搬的“完整骨架”）

> 说明：下面代码以你项目现有思路为准：  
> - 你已经有 `EmbeddingService`、`DashScopeEmbeddingService`  
> - 你已经有 `QdrantVectorStore`（gRPC `io.qdrant:client:1.10.0`）  
> - 你已经有 `Document`、`Chunk` 实体  
> - 你使用多租户（`SecurityUtil.currentTenantId()` 或 `TenantContextHolder`）
>
> 你需要做的是：**把这些类按你的包名/mapper/字段名做轻微适配**。

### 5.1 DTO：检索返回结构（对齐你字段）

```java
package com.ityfz.yulu.knowledge.dto;

import lombok.*;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RetrievalResultDTO {
    private Long documentId;
    private Long chunkId;
    private Integer chunkIndex; // 对齐你的字段
    private String title;
    private String source;
    private String fileType;
    private String chunkText;
    private Double score;
}
```

### 5.2 Service：索引服务（按文档索引，按你 Mapper）

```java
package com.ityfz.yulu.knowledge.service;

public interface ChunkIndexService {

    /** 索引某个文档下所有 chunk（幂等） */
    void indexDocument(Long tenantId, Long documentId);

    /** 重建索引：先删 Qdrant 再索引（可选） */
    void rebuildDocumentIndex(Long tenantId, Long documentId);
}
```

实现：

```java
package com.ityfz.yulu.knowledge.service.impl;

import com.ityfz.yulu.common.ai.EmbeddingService;
import com.ityfz.yulu.common.ai.impl.QdrantVectorStore;
import com.ityfz.yulu.knowledge.entity.Chunk;
import com.ityfz.yulu.knowledge.entity.Document;
import com.ityfz.yulu.knowledge.mapper.ChunkMapper;
import com.ityfz.yulu.knowledge.mapper.DocumentMapper;
import com.ityfz.yulu.knowledge.service.ChunkIndexService;
import io.qdrant.client.grpc.JsonWithInt;
import io.qdrant.client.grpc.Points;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
public class ChunkIndexServiceImpl implements ChunkIndexService {

    private static final String COLLECTION = "yulu_chunks";

    private final EmbeddingService embeddingService;
    private final QdrantVectorStore qdrantVectorStore;
    private final DocumentMapper documentMapper;
    private final ChunkMapper chunkMapper;

    @Override
    @Transactional
    public void indexDocument(Long tenantId, Long documentId) {
        Document doc = documentMapper.selectByTenantIdAndId(tenantId, documentId);
        if (doc == null) {
            throw new IllegalArgumentException("文档不存在或不属于当前租户: " + documentId);
        }

        List<Chunk> chunks = chunkMapper.listByDocumentIdAndTenantId(documentId, tenantId);
        if (chunks == null || chunks.isEmpty()) {
            log.info("文档无 chunk，无需索引. docId={}", documentId);
            return;
        }

        // 1) 批量向量化
        List<String> texts = chunks.stream().map(Chunk::getContent).toList();
        List<List<Float>> vectors = embeddingService.embedBatch(texts);
        if (vectors.size() != chunks.size()) {
            throw new IllegalStateException("embedding 返回数量不一致: chunks=" + chunks.size() + ", vectors=" + vectors.size());
        }

        // 2) 组装 points 并 upsert 到 Qdrant
        for (int i = 0; i < chunks.size(); i++) {
            Chunk c = chunks.get(i);
            List<Float> v = vectors.get(i);

            // 维度一致性校验（强烈建议保留）
            if (v == null || v.size() != embeddingService.getDimension()) {
                throw new IllegalStateException("向量维度不匹配: got=" + (v == null ? 0 : v.size())
                        + ", expected=" + embeddingService.getDimension());
            }

            long pointId = c.getId(); // 幂等策略：pointId=chunkId
            Map<String, JsonWithInt.Value> payload = buildPayload(tenantId, doc, c);
            qdrantVectorStore.upsertPoint(COLLECTION, pointId, v, payload);

            c.setQdrantPointId(pointId);
        }

        // 3) 批量更新 chunk 的 qdrantPointId（你目前 Mapper 没有批量方法，可选择循环 update 或补一个批量方法）
        //   如需批量方法，请在 Mapper + XML 中新增；此处示例循环更新（简单但多 SQL）
        for (Chunk c : chunks) {
            chunkMapper.updateById(c); // 仅更新 qdrantPointId，确保字段有值
        }

        // 4) 更新文档索引时间/状态
        doc.setIndexedAt(LocalDateTime.now());
        doc.setStatus(1); // 1-已索引
        documentMapper.updateById(doc);

        log.info("索引完成 docId={}, chunkCount={}", documentId, chunks.size());
    }

    @Override
    @Transactional
    public void rebuildDocumentIndex(Long tenantId, Long documentId) {
        // 可选：删除该文档在 Qdrant 的所有点（按 payload 过滤 document_id）
        qdrantVectorStore.deleteByFilter(COLLECTION, qdrantVectorStore.eqLong("tenant_id", tenantId),
                qdrantVectorStore.eqLong("document_id", documentId));

        // 清空 DB 映射（可选：需你在 Mapper 中实现）
        // chunkMapper.clearQdrantPointIdByDocument(documentId, tenantId);
        // documentMapper.clearIndexedAt(documentId, tenantId);

        // 重新索引
        indexDocument(tenantId, documentId);
    }

    private Map<String, JsonWithInt.Value> buildPayload(Long tenantId, Document doc, Chunk c) {
        Map<String, Object> raw = new LinkedHashMap<>();
        raw.put("tenant_id", tenantId);
        raw.put("document_id", doc.getId());
        raw.put("chunk_id", c.getId());
        raw.put("order_no", c.getChunkIndex()); // 对齐你的字段
        raw.put("title", doc.getTitle());
        raw.put("source", doc.getSource());
        raw.put("file_type", doc.getFileType());

        // chunk 文本建议截断，避免 payload 过大（按你实际 chunkSize 决定）
        raw.put("chunk", safeTruncate(c.getContent(), 4000));
        return qdrantVectorStore.objectToPayload(raw);
    }

    private String safeTruncate(String s, int max) {
        if (s == null) return null;
        if (s.length() <= max) return s;
        return s.substring(0, max);
    }
}
```

> **注意**：上述 `documentMapper/ chunkMapper` 方法名是示例，你需要按你真实 Mapper 改一下（核心思想不变）。

### 5.3 Service：检索服务（对齐你 QdrantVectorStore.search 签名）

```java
package com.ityfz.yulu.knowledge.service;

import com.ityfz.yulu.knowledge.dto.RetrievalResultDTO;
import java.util.List;

public interface KnowledgeSearchService {
    List<RetrievalResultDTO> search(Long tenantId, String query, int topK, double minScore);
}
```

实现：

```java
package com.ityfz.yulu.knowledge.service.impl;

import com.ityfz.yulu.common.ai.EmbeddingService;
import com.ityfz.yulu.common.ai.impl.QdrantVectorStore;
import com.ityfz.yulu.knowledge.dto.RetrievalResultDTO;
import com.ityfz.yulu.knowledge.service.KnowledgeSearchService;
import io.qdrant.client.grpc.JsonWithInt;
import io.qdrant.client.grpc.Points;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class KnowledgeSearchServiceImpl implements KnowledgeSearchService {

    private static final String COLLECTION = "yulu_chunks";

    private final EmbeddingService embeddingService;
    private final QdrantVectorStore qdrantVectorStore;

    @Override
    public List<RetrievalResultDTO> search(Long tenantId, String query, int topK, double minScore) {
        List<Float> qv = embeddingService.embed(query);
        if (qv == null || qv.size() != embeddingService.getDimension()) {
            throw new IllegalStateException("query 向量维度异常: got=" + (qv == null ? 0 : qv.size())
                    + ", expected=" + embeddingService.getDimension());
        }

        // Qdrant 搜索（tenant 过滤 + payload 返回）
        Points.Filter filter = buildTenantFilter(tenantId);
        List<Points.ScoredPoint> points = qdrantVectorStore.search(COLLECTION, qv, topK, filter);

        // 二次排序 + 阈值过滤 + DTO 化
        return points.stream()
                .sorted(Comparator.comparingDouble(Points.ScoredPoint::getScore).reversed())
                .filter(p -> p.getScore() >= minScore)
                .map(this::toDTO)
                .collect(Collectors.toList());
    }

    private RetrievalResultDTO toDTO(Points.ScoredPoint p) {
        Map<String, JsonWithInt.Value> payload = p.getPayloadMap();

        return RetrievalResultDTO.builder()
                .tenantId(getLong(payload, "tenant_id"))
                .documentId(getLong(payload, "document_id"))
                .chunkId(getLong(payload, "chunk_id"))
                .chunkIndex(getInt(payload, "order_no")) // payload 用 order_no 存放 chunkIndex
                .title(getString(payload, "title"))
                .source(getString(payload, "source"))
                .fileType(getString(payload, "file_type"))
                .chunkText(getString(payload, "chunk"))
                .score(p.getScore())
                .build();
    }

    private Points.Filter buildTenantFilter(Long tenantId) {
        if (tenantId == null) return null;
        Points.FieldCondition cond = Points.FieldCondition.newBuilder()
                .setKey("tenant_id")
                .setMatch(Points.Match.newBuilder().setInteger(tenantId))
                .build();
        return Points.Filter.newBuilder().addMust(Points.Condition.newBuilder().setField(cond)).build();
    }

    private Long getLong(Map<String, JsonWithInt.Value> p, String k) {
        JsonWithInt.Value v = p.get(k);
        if (v == null) return null;
        if (v.hasInteger()) return v.getInteger();
        if (v.hasDouble()) return (long) v.getDouble();
        if (v.hasStringValue()) return Long.parseLong(v.getStringValue());
        return null;
    }

    private Integer getInt(Map<String, JsonWithInt.Value> p, String k) {
        Long l = getLong(p, k);
        return l == null ? null : l.intValue();
    }

    private String getString(Map<String, JsonWithInt.Value> p, String k) {
        JsonWithInt.Value v = p.get(k);
        if (v == null) return null;
        if (v.hasStringValue()) return v.getStringValue();
        if (v.hasInteger()) return String.valueOf(v.getInteger());
        if (v.hasDouble()) return String.valueOf(v.getDouble());
        if (v.hasBool()) return String.valueOf(v.getBool());
        return null;
    }
}
```

> 上面 DTO 里我示例加了 `tenantId` 字段，如果你不需要就删掉；保持 “返回结构完整” 即可。

---

## 6. QdrantVectorStore：基于你现有实现的补充与建议

### 6.1 创建 collection（createCollection）

你已有 `createCollection`、`upsertPoint`、`search`、`objectToValue`。建议补充/调整：

1) **createCollectionIfNotExists**：启动时自动创建（尺寸=Embedding 维度，距离=Cosine）。你的 `listCollectionsAsync().get()` 返回的是 `Collections.ListCollectionsResponse`，需注意取集合名列表。示例：

```java
public void createCollectionIfNotExists(String name, int dimension) {
    try {
        var resp = client.listCollectionsAsync().get(); // 返回 ListCollectionsResponse
        boolean exists = resp.getCollectionsList().stream()
                .anyMatch(ci -> name.equals(ci.getName()));
        if (exists) return;

        Collections.VectorParams vectorParams = Collections.VectorParams.newBuilder()
                .setSize(dimension)
                .setDistance(Collections.Distance.Cosine)
                .build();
        client.createCollectionAsync(name, vectorParams).get();
        log.info("[Qdrant] 创建集合成功: {}, dim={}", name, dimension);
    } catch (Exception e) {
        throw new RuntimeException("创建集合失败", e);
    }
}
```

2) **批量 upsert（可选）**：一次写多条，减少 RPC
```java
public void upsertPoints(String collection, List<Points.PointStruct> points) {
    try {
        client.upsertAsync(collection, points).get();
    } catch (Exception e) {
        throw new RuntimeException("批量 upsert 失败", e);
    }
}
```

3) **按条件删除（可选，用于重建索引）**  
Qdrant 1.10.0 delete filter 需构造 `Points.Filter`，示例仅供参考：
```java
public void deleteByFilter(String collection, Points.Filter filter) {
    try {
        client.deleteAsync(collection, filter).get();
    } catch (Exception e) {
        throw new RuntimeException("按过滤删除失败", e);
    }
}
```

4) **objectToPayload 辅助**：你已有 `objectToValue(Object)`，可再包一层：
```java
public Map<String, JsonWithInt.Value> objectToPayload(Map<String, Object> raw) {
    Map<String, JsonWithInt.Value> m = new HashMap<>();
    if (raw == null) return m;
    raw.forEach((k,v) -> {
        JsonWithInt.Value val = objectToValue(v);
        if (val != null) m.put(k, val);
    });
    return m;
}
```

### 6.2 写入点（upsert）

**payload** 的类型是 `Map<String, JsonWithInt.Value>`（你已踩过坑）。

你需要具备：
- `upsertPoint(collection, pointId, vector, payload)` 单条写入（简单可靠）
- （可选）`upsertPoints(collection, List<PointStruct>)` 批量写入（高性能）

### 6.3 搜索（search）

至少支持：
- topK
- withPayload
- tenant filter（强烈建议）

### 6.4 删除（delete）

重建索引或文档删除时需要：
- 按条件删除（payload filter：tenant_id + document_id）
- 或按 pointId 列表删除

Qdrant 典型删除方式：
- delete by filter
- delete points by ids

---

## 7. Controller：给你一个“索引 + 检索”最小闭环接口

> 你已写了 `DocumentController`（上传/列表/详情/删除），这里补齐索引与检索 API。

### 7.1 索引接口

```java
@RestController
@RequestMapping("/api/admin/knowledge")
@RequiredArgsConstructor
public class KnowledgeIndexController {

    private final ChunkIndexService chunkIndexService;

    @PostMapping("/document/{documentId}/index")
    public ApiResponse<Void> index(@PathVariable Long documentId) {
        Long tenantId = SecurityUtil.currentTenantId();
        chunkIndexService.indexDocument(tenantId, documentId);
        return ApiResponse.success();
    }

    @PostMapping("/document/{documentId}/rebuild")
    public ApiResponse<Void> rebuild(@PathVariable Long documentId) {
        Long tenantId = SecurityUtil.currentTenantId();
        chunkIndexService.rebuildDocumentIndex(tenantId, documentId);
        return ApiResponse.success();
    }
}
```

### 7.2 检索接口

```java
@RestController
@RequestMapping("/api/admin/knowledge")
@RequiredArgsConstructor
public class KnowledgeSearchController {

    private final KnowledgeSearchService knowledgeSearchService;

    @GetMapping("/search")
    public ApiResponse<List<RetrievalResultDTO>> search(
            @RequestParam("q") String q,
            @RequestParam(value = "topK", defaultValue = "10") Integer topK,
            @RequestParam(value = "minScore", defaultValue = "0.35") Double minScore
    ) {
        Long tenantId = SecurityUtil.currentTenantId();
        return ApiResponse.success(knowledgeSearchService.search(tenantId, q, topK, minScore));
    }
}
```

---

## 8. Postman 测试步骤（你可以按这个顺序验证）

### 8.1 上传文档（你已跑通）

- `POST /api/admin/document/upload`
- Body: form-data
  - `file`: File
  - 其他字段按你 controller 定义

### 8.2 索引该文档

- `POST /api/admin/knowledge/document/{documentId}/index`
- Header：`Authorization: Bearer xxx`
- 预期：
  - 返回 success
  - DB：该文档 chunks `qdrantPointId` 被填充
  - DB：`Document.indexedAt` 更新
  - Qdrant：collection 中出现对应 points

### 8.3 检索

- `GET /api/admin/knowledge/search?q=你的问题&topK=10&minScore=0.35`
- 预期：
  - 返回列表包含 `chunkText/title/source/orderNo/score`
  - `score` 从高到低

### 8.4 排查建议（若查不到）

- 确认 Qdrant 是否启动、gRPC 端口是否正确（默认 6334）
- 确认 collection 的 `vector size` 是否与 embedding 维度一致
- 确认 upsert 时 vector 长度是否正确
- 确认 search 是否加了 tenant filter，payload 的 `tenant_id` 是否写入正确
- 先把 `minScore` 调低到 0.1 看是否能命中，再逐步调高

---

## 9. 常见坑与解决方案（非常实用）

### 9.1 维度不一致导致 upsert/search 失败

症状：
- upsert 报错
- 或 upsert 成功但检索命中异常

解决：
- 在索引前加校验：`vector.size() == embeddingService.getDimension()`
- 创建 collection 时使用 `embeddingService.getDimension()`

### 9.2 payload 类型不匹配（你之前已遇到）

Qdrant Java client 1.10.0：
- `putAllPayload` 需要 `Map<String, JsonWithInt.Value>`

解决：
- 统一写 `objectToPayload(Map<String,Object>)` 转换
- 对 String/Long/Double/Boolean/List<String> 做明确映射

### 9.3 payload 放 chunk 文本过大

症状：
- 写入慢、payload 超大、内存开销高

解决：
- 截断（4000 字符只是示例，你按 `chunkSize` 调整）
- 或 payload 只放 chunkId，检索结果再回 DB 查 `Chunk.content`

### 9.4 多租户隔离

必须保证：
- upsert payload 写入 `tenant_id`
- search filter 使用 `tenant_id` 条件

否则会出现跨租户命中，非常严重。

---

## 10. 下一步拓展（你完成检索闭环后再做）

- **Rerank**：对 Top-K 再用更强模型重排（提升精度）
- **Hybrid Search**：向量 + BM25（更稳）
- **多段合并**：同一文档命中多个 chunk 时做合并/去重
- **引用定位**：返回 `documentId + chunkOrderNo` 给前端做高亮定位
- **异步索引**：上传后入队列（xxl-job/消息队列）后台索引，避免接口阻塞

---

## 11. 你需要我下一步继续补齐什么？

如果你希望我把文档进一步“对齐到你当前代码的真实方法名与字段名”，我需要你确认/贴一下（任意一种即可）：
- `Document`、`Chunk` 实体字段（尤其：`title/source/fileType/orderNo/qdrantPointId/tenantId` 的真实字段名）
- `ChunkMapper` / `DocumentMapper` 里目前有哪些查询与更新方法（截图/代码都行）
- 你当前 `QdrantVectorStore` 已有的方法签名（尤其：createCollection/upsert/search/objectToValue）



